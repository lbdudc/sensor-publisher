/*% if (feature.MWM_TE_Statistics) { %*/
<template>
  <v-container fluid>
    <v-card class="card">
      <v-card-title class="pt-0 pb-0">
        <v-container fluid style="z-index: 0;">
          <v-col class="d-none d-md-block pl-0">
            <span class="headline no-split-words">
              {{ $t($route.meta.label) }}
            </span>
          </v-col>
          <v-row no-gutters class="mt-1">
            <label class="title">{{ $t("trajectory_exploitation.statistics.title.before") }}</label>
            <v-col cols="12" sm="2" lg="1">
              <v-select
                dense
                solo
                item-text="label"
                item-value="value"
                :items="switchOptions"
                v-model="switchValue"
                class="switch"
                @change="search"
                :menu-props="{ offsetY: true }"
              ></v-select>
            </v-col>
            <label class="title">{{ $t("trajectory_exploitation.statistics.title.after") }}</label>
            <v-col class="date-picker-container mt-2">
              <dateAndHourPicker
                :datePickerProp="{
                  data: startDate,
                  label: $t('trajectory_exploitation.startDate'),
                  mandatory: true
                }"
                @update-time="saveDate('startDate', ...arguments)"
                ref="startDate"
                v-if="dateLoaded"
              ></dateAndHourPicker>
            </v-col>
            <label class="title">
              {{ $t("trajectory_exploitation.and") }}
            </label>
            <v-col class="date-picker-container mt-2">
              <dateAndHourPicker
                :datePickerProp="{
                  data: endDate,
                  label: $t('trajectory_exploitation.endDate'),
                  mandatory: true
                }"
                @update-time="saveDate('endDate', ...arguments)"
                ref="endDate"
                v-if="dateLoaded"
              ></dateAndHourPicker>
            </v-col>
          </v-row>
        </v-container>
      </v-card-title>
      <v-card-text>
        <v-row class="mx-5" no-gutters>
          <v-col class="text-center">
            <statistics-table
              :statistics-data="statisticsData"
              :sortable="false"
              :hideFooter="true"
              @filter="redirectToRecord"
            ></statistics-table>
          </v-col>
        </v-row>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script>
import {compareLocalDates} from "@/common/comparation-utils";
import { localDateToISOString } from "@/common/conversion-utils";
import StatisticsTable from "./ActivityStatisticsTable";
import DateAndHourPicker from "../calendar/DateAndHourPicker";
import RepositoryFactory from "@/repositories/RepositoryFactory";
const TrajectoryExploitationRepository = RepositoryFactory.get("TrajectoryExploitationRepository");

export default {
  name: "ActivitiesStatistics",
  components: {
    DateAndHourPicker,
    StatisticsTable
  },
  data() {
    return {
      startDate: null,
      endDate: null,
      statisticsData: [],
      switchValue: false, // False == "Total" || True == "Average",
      dateLoaded: false // Prevents date picker from loading empty
    };
  },
  computed: {
    switchOptions() {
      return [
        {
          label: this.$t("trajectory_exploitation.statistics.title.total"),
          value: false
        },
        {
          label: this.$t("trajectory_exploitation.statistics.title.average"),
          value: true
        }
      ];
    }
  },
  beforeMount() {
    this.switchValue = this.$route.query.type == "Average" ? true : false;

    this.categories = TrajectoryExploitationRepository
    .getAllActivityCategories().then(data => {
      this.categories = data;
    });

    const promise1 = new Promise(resolve => {
      if (!this.$route.query.start) {
        TrajectoryExploitationRepository.getFirstDay()
          .then(data => {
            this.startDate = data.map(str => parseInt(str));
            resolve();
          });
      } else {
        this.startDate = this.$route.query.start
          .split("_")
          .map(str => parseInt(str));
        resolve();
      }
    });

    const promise2 = new Promise(resolve => {
      if (!this.$route.query.end) {
        TrajectoryExploitationRepository.getLastDay()
          .then(data => {
            this.endDate = data.map(str => parseInt(str));
            resolve();
          });
      } else {
        this.endDate = this.$route.query.end
          .split("_")
          .map(str => parseInt(str));
        resolve();
      }
    });

    Promise.all([promise1, promise2]).then(() => {
      if (parseInt(this.startDate.join("")) < parseInt(this.endDate.join(""))) {
        this.endDate = this.startDate;
      }
      this.dateLoaded = true;
      this.search();
    });
  },
  methods: {
    redirect() {
      const query = {
        start: this.startDate ? this.startDate.join("_") : undefined,
        end: this.endDate ? this.endDate.join("_") : undefined,
        type: this.switchValue ? "Average" : "Total"
      };
      if (JSON.stringify(this.$route.query) !== JSON.stringify(query)) {
        this.$router.replace({
          query: query
        });
      }
    },
    redirectToRecord(categoryName) {
      const category = this.categories.find(c => c.label === categoryName);
      this.$router.push({
        name: "Record",
        params: {
          start: this.startDate.join("_"),
          end: this.endDate.join("_")
        },
        query: { category: category ? category.id : undefined, searchType: 2 }
      });
    },
    search() {
      const options = {
        params: {
          start: localDateToISOString(this.startDate),
          end:
            this.endDate != null
              ? localDateToISOString(this.endDate)
              : undefined,
          type: this.switchValue ? "Average" : "Total"
        }
      };

      TrajectoryExploitationRepository.getStatistics(options)
        .then(data => (this.statisticsData = data));

      this.redirect();
    },
    saveDate(prop, data) {
      this[prop] = data.date;
      if (this.startDate) {
        if (
          !this.endDate ||
          compareLocalDates(this.startDate, this.endDate) < 0
        ) {
          // Eliminates date picker errors
          this.$refs.startDate.setDatePickerErrorMessage(null);
          if (this.endDate) {
            this.$refs.endDate.setDatePickerErrorMessage(null);
          }
          this.search();
        } else {
          this.$notify({
            text: this.$t("trajectory_exploitation.endDateError"),
            type: "error"
          });
          this.$refs[prop].setDatePickerErrorMessage(
            this.$t("calendar.endTimeValidationError")
          );
        }
      }
    },
  }
};
</script>

<style scoped>
.title {
  margin-right: 10px;
  margin-left: 10px;
  margin-top: 6px;
}
.switch {
  padding-top: 0;
  margin-top: 2px;
  margin-right: 10px;
  word-break: break-word;
}
.card {
  height: 90vh;
}
@media (max-width: 992px) {
  .card {
    height: auto;
  }
}
.date-picker-container {
  min-width: 125px;
}
</style>
/*% } %*/
