/*% if (feature.MWM_TE_QueryView) { %*/
<template>
  <v-container fluid>
    <v-col class="d-none d-md-block pl-0">
      <span class="headline no-split-words">
        {{ $t($route.meta.label) }}
      </span>
    </v-col>
    <v-row no-gutters class="mt-1">
      <label class="title ml-0">
        {{ $t("trajectory_exploitation.whenActivityOcurred") }}
      </label>
      <v-select
        v-model="form.categories"
        class="mr-3 mt-1"
        style="max-width: 200px;"
        :items="categories"
        :menu-props="{ offsetY: true }"
        item-text="label"
        item-value="id"
        @change="searchInMap('category')"
        autocomplete="off"
        return-object
        multiple
        dense
        solo
      ></v-select>
      <label class="title ml-0">
        {{ $t("trajectory_exploitation.madeBy") }}
      </label>
      <v-col cols="12" sm="6" md="4" lg="3" class="pt-1 pr-2 employee-selector">
        <autocomplete
          :debouncing="300"
          select-all
          v-model="form.employees"
          :label="$t('trajectory_exploitation.employeesLabel')"
          :items="employees"
          item-text="fullName"
          @change="searchInMap('employees')"
          return-object
          multiple
          dense
          solo
          abreviate
        >
        </autocomplete>
      </v-col>
      <v-select
        v-model="form.inBetweenSearch"
        class="mr-3 mt-1"
        style="max-width: 100px;"
        item-text="label"
        item-value="id"
        :items="searchTypes.inBetween"
        :menu-props="{ offsetY: true }"
        @change="searchInMap('inBetweenSearch')"
        dense
        solo
      ></v-select>
      <v-col class="date-picker-container">
        <dateAndHourPicker
          :datePickerProp="{
            data: form.startDate,
            label: $t('trajectory_exploitation.startDate'),
            mandatory: true
          }"
          @update-time="saveDate('startDate', ...arguments)"
          ref="startDate"
          v-if="dateLoaded"
        ></dateAndHourPicker>
      </v-col>
      <label class="title" v-show="form.inBetweenSearch != 0">
        {{ $t("trajectory_exploitation.and") }}
      </label>
      <v-col
        class="date-picker-container"
        v-show="form.inBetweenSearch != 0 && dateLoaded"
      >
        <dateAndHourPicker
          :datePickerProp="{
            data: form.endDate,
            label: $t('trajectory_exploitation.endDate'),
            mandatory: true
          }"
          @update-time="saveDate('endDate', ...arguments)"
          ref="endDate"
        ></dateAndHourPicker>
      </v-col>
      <label class="title">
        {{ $t("trajectory_exploitation.endInterrogation") }}
      </label>
    </v-row>
    <v-divider class="d-block d-md-none my-2"/>
    <v-row class="mt-1 ml-4" style="min-height: 60px" no-gutters>
      <v-checkbox
        class="mt-0"
        v-model="checkBoxes.delimitZone"
        @change="searchInMap('checkBoxes.delimitZone')"
      >
        <template v-slot:label>
          <div>
            <label class="title ml-0">
              {{ $t("trajectory_exploitation.thatHappened") }}
            </label>
          </div>
        </template>
      </v-checkbox>
      <v-select
        v-model="form.delimitedZoneSearchType"
        class="mt-0"
        style="max-width: 250px;"
        item-text="label"
        item-value="id"
        :items="searchTypes.delimitedZoneType"
        :menu-props="{ offsetY: true }"
        @change="searchInMap"
        :disabled="!checkBoxes.delimitZone"
        :error="form.delimitedZoneSearchType == null && checkBoxes.delimitZone"
        dense
        solo
      ></v-select>
      <label class="title advanced-query-title">
        {{ $t("trajectory_exploitation.theNextZone") }}
      </label>
      <v-btn
        class="mt-sm-1"
        :color="checkBoxes.delimitZone && form.bbox == null ? 'red' : 'normal'"
        @click="startDraw"
        :disabled="!checkBoxes.delimitZone"
      >
        {{
        drawing
        ? $t("trajectory_exploitation.cancel")
        : $t("trajectory_exploitation.delimitZone")
        }}
      </v-btn>
    </v-row>
    <v-divider class="d-block d-md-none my-2"/>
    <v-row class="mt-1 ml-4" no-gutters>
      <v-checkbox
        class="mt-0"
        v-model="checkBoxes.advancedQueryCategory"
        @change="searchInMap('checkBoxes.advancedQueryCategory')"
      >
        <template v-slot:label>
          <div>
            <label class="title ml-0">
              {{ $t("trajectory_exploitation.activityHasBeenDone") }}
            </label>
          </div>
        </template>
      </v-checkbox>
      <v-select
        v-model="form.advancedQueryTemporalRelation"
        class="mt-1"
        style="max-width: 125px;"
        item-text="label"
        item-value="id"
        :items="searchTypes.beforeAfter"
        :menu-props="{ offsetY: true }"
        @change="searchInMap"
        :disabled="!checkBoxes.advancedQueryCategory"
        :error="
          form.advancedQueryTemporalRelation == null &&
            checkBoxes.advancedQueryCategory
        "
        dense
        solo
      ></v-select>
      <label class="title advanced-query-title">
        {{ $t("trajectory_exploitation.theActivity") }}
      </label>
      <v-select
        v-model="form.advancedQueryCategory"
        class="mt-1"
        style="max-width: 200px;"
        item-text="label"
        item-value="id"
        :items="activityCategories"
        :menu-props="{ offsetY: true }"
        @change="searchInMap"
        :disabled="!checkBoxes.advancedQueryCategory"
        :error="
          form.advancedQueryCategory == null && checkBoxes.advancedQueryCategory
        "
        dense
        solo
      ></v-select>
    </v-row>
    <v-divider class="d-block d-md-none my-2"/>
    <v-row class="mt-1 ml-4" no-gutters>
      <v-checkbox
        class="mt-0"
        v-model="checkBoxes.advancedQueryTime"
        @change="searchInMap('checkBoxes.advancedQueryTime')"
      >
        <template v-slot:label>
          <div>
            <label class="title ml-0">
              {{ $t("trajectory_exploitation.activityDurationHasBeen") }}
            </label>
          </div>
        </template>
      </v-checkbox>
      <v-select
        v-model="form.advancedQueryTimeComparation"
        class="mt-1"
        style="max-width: 125px;"
        item-text="label"
        item-value="id"
        :items="searchTypes.greaterLess"
        :menu-props="{ offsetY: true }"
        @change="searchInMap"
        :disabled="!checkBoxes.advancedQueryTime"
        :error="
          form.advancedQueryTimeComparation == null &&
            checkBoxes.advancedQueryTime
        "
        dense
        solo
      ></v-select>
      <label class="title advanced-query-title">
        {{ $t("trajectory_exploitation.than") }}
      </label>
      <v-text-field
        v-model="form.advancedQueryTime"
        class="mt-2"
        style="max-width: 100px;"
        type="number"
        @change="searchInMap"
        :disabled="!checkBoxes.advancedQueryTime"
        :error="form.advancedQueryTime == null && checkBoxes.advancedQueryTime"
        dense
      ></v-text-field>
      <label class="title advanced-query-title">
        {{ $t("trajectory_exploitation.minutes") }}
      </label>
    </v-row>
    <v-divider class="d-block d-md-none my-2"/>
    <v-row no-gutters>
      <v-col cols="12" md="6" ref="mapContainer">
        <v-container ref="map" id="map"></v-container>
      </v-col>
      <v-col cols="12" md="6" class="pl-md-2 pt-2 pt-md-0 pb-0">
        <v-card class="pl-lg-5 pl-3 card">
          <component
            :is="detailComponent"
            :features="selectedFeatures"
            :canGoBack="backFeatures != null"
            :canClose="true"
            @close="close"
            @back="back"
            @go-to="goTo"
            v-if="detailComponent"
          ></component>
          <v-container fill-height v-if="!detailComponent">
            <v-row class="text-center" justify="center">
              <v-col cols="12">
                <label id="click-on-activity-label">
                  {{ $t("trajectory_exploitation.clickOnActivity") }}
                </label>
              </v-col>
            </v-row>
          </v-container>
        </v-card>
      </v-col>
    </v-row>
  </v-container>
</template>

<script>
import updateLayer from "./utils/updateLayer";
import initMap from "@/common/initMap";
import { localDateToISOString } from "@/common/conversion-utils";
import {compareLocalDates} from "@/common/comparation-utils";
import DateAndHourPicker from "../calendar/DateAndHourPicker";
import ClientDetail from "./details/ClientDetail";
import EmployeeDetail from "./details/EmployeeDetail";
import EventDetail from "./details/EventDetail";
import ActivityDetail from "./details/ActivityDetail";
import Autocomplete from "@/components/debouncing-inputs/Autocomplete.vue";
import RepositoryFactory from "@/repositories/RepositoryFactory";
const TrajectoryExploitationRepository = RepositoryFactory.get(
  "TrajectoryExploitationRepository"
);
const highlightStyle = (highlight, subLayer) => {
  const HIGHLIGHT_COLOR = "#FFFF00";
  return {
    color: highlight
      ? HIGHLIGHT_COLOR
      : subLayer.feature.properties.category_color,
    fillColor: highlight
      ? HIGHLIGHT_COLOR
      : subLayer.feature.properties.category_color,
    fillOpacity:
      subLayer.feature.geometry.type == "Point"
        ? highlight
        ? 1.0
        : 0.55
        : 0,
    opacity: highlight ? 1.0 : 0.55
  }
};
var oldHighlightedIds = null;

export default {
  name: "MobilityQuery",
  data() {
    return {
      backFeatures: null,
      backComponent: null,
      selectedFeatures: null,
      detailComponent: null,
      form: {
        employees: [],
        startDate: null,
        endDate: null,
        categories: [],
        inBetweenSearch: 0,
        advancedQueryCategory: 0,
        activityId: null,
        advancedQueryTime: null,
        delimitedZoneSearchType: null,
        bbox: null,
        advancedQueryTemporalRelation: null,
        advancedQueryTimeComparation: null
      },
      checkBoxes: {
        advancedQueryCategory: false,
        advancedQueryTime: false,
        delimitZone: false
      },
      categories: [
        { id: 0, label: this.$t("trajectory_exploitation.allCategories") }
      ],
      employees: [],
      searchTypes: {
        inBetween: [
          { id: 0, label: this.$t("trajectory_exploitation.in") },
          { id: 1, label: this.$t("trajectory_exploitation.between") }
        ],
        beforeAfter: [
          { id: "BEFORE", label: this.$t("trajectory_exploitation.before") },
          { id: "AFTER", label: this.$t("trajectory_exploitation.after") }
        ],
        greaterLess: [
          { id: "GREATER", label: this.$t("trajectory_exploitation.greater") },
          { id: "LESS", label: this.$t("trajectory_exploitation.less") }
        ],
        delimitedZoneType: [
          {
            id: "OUTSIDE",
            label: this.$t("trajectory_exploitation.totallyOutside")
          },
          {
            id: "PARTIALLY_IN",
            label: this.$t("trajectory_exploitation.partiallyWithin")
          },
          {
            id: "INSIDE",
            label: this.$t("trajectory_exploitation.totallyWithin")
          }
        ]
      },
      activities: [],
      activityCategories: [],
      activitiesLayer: null,
      beforeMountPromise: null,
      dateLoaded: false, // Prevents date picker from loading empty
      drawing: false,
      getCategoriesPromise: null,
      map: null,
      mapDelimiter: null
    };
  },
  computed: {
    advancedQueryCategoryError() {
      return (
        this.checkBoxes.advancedQueryCategory &&
        (this.form.advancedQueryCategory == null ||
          this.form.advancedQueryTemporalRelation == null)
      );
    },
    advancedQueryTimeError() {
      return (
        this.checkBoxes.advancedQueryTime &&
        (this.form.advancedQueryTime == null ||
          this.form.advancedQueryTimeComparation == null)
      );
    },
    delimitZoneError() {
      return (
        this.checkBoxes.delimitZone &&
        this.form.bbox == null &&
        this.form.delimitedZoneSearchType == null
      );
    }
  },
  components: {
    DateAndHourPicker,
    Autocomplete,
    "client-detail": ClientDetail,
    "employee-detail": EmployeeDetail,
    "event-detail": EventDetail,
    "activity-detail": ActivityDetail
  },
  beforeMount() {
    this.form.inBetweenSearch = this.$route.query.inBetweenSearch
      ? parseInt(this.$route.query.inBetweenSearch)
      : 0;
    if (
      this.$route.query.advancedQueryTemporalRelation != null &&
      this.$route.query.activityCat
    ) {
      this.checkBoxes.advancedQueryCategory = true;
      this.form.advancedQueryTemporalRelation = this.$route.query.advancedQueryTemporalRelation;
      this.form.advancedQueryCategory = parseInt(this.$route.query.activityCat);
    }
    if (
      this.$route.query.advancedQueryTimeComparation != null &&
      this.$route.query.advancedQueryTime
    ) {
      this.checkBoxes.advancedQueryTime = true;
      this.form.advancedQueryTimeComparation = this.$route.query.advancedQueryTimeComparation;
      this.form.advancedQueryTime = this.$route.query.advancedQueryTime;
    }

    this.form.activityId = this.$route.query.activity;

    this.beforeMountPromise = new Promise(resolve => {
      if (this.$route.params.start) {
        this.form.startDate = this.$route.params.start
          .split("_")
          .map(str => parseInt(str));
        if (this.form.inBetweenSearch === 1 && this.$route.params.end) {
          this.form.endDate = this.$route.params.end
            .split("_")
            .map(str => parseInt(str));
        }
        resolve();
      } else {
        TrajectoryExploitationRepository.getLastDay()
          .then(data => {
            this.form.startDate = data.map(str => parseInt(str));
            if (this.form.inBetweenSearch === 1) {
              this.form.endDate = data.map(str => parseInt(str));
            }
            resolve();
          });
      }
    });

    this.getCategoriesPromise = new Promise(resolve => {
      TrajectoryExploitationRepository.getAllActivityCategories()
        .then(data => {
          this.categories = this.categories.concat(data);
          this.activityCategories = data;
          if (this.$route.query.categories) {
            this.form.categories = this.categories.filter(e =>
              this.$route.query.categories
                .split(",")
                .map((el) => parseInt(el))
                .includes(e.id)
            );
          }
          resolve();
        });
    });
  },
  mounted() {
    this.map = initMap("map", "mobilityQuery", [
      [41.508742458803326, -4.087890625],
      [44.508742458803326, -12.087890625]
    ]);

    // Creating empty activities layer
    this.activitiesLayer = new MV.GeoJSONLayer(
      {
        type: "FeatureCollection",
        features: []
      },
      {
        id: "activities-geom",
        label: "activities-geom",
        baseLayer: false,

        // Showing GeoJSON info
        click: event => this.showActivityDetail(event.layer.feature.id)
      }
    );
    this.map.addLayer(this.activitiesLayer);

    // Getting all the employees and calling to update employees layer to represent the selected ones
    TrajectoryExploitationRepository.getAllEmployees()
      .then(data => {
        this.employees = this.employees.concat(data);
        if (this.$route.query.employees != null) {
          this.form.employees = this.employees.filter(e =>
            this.$route.query.employees
              .split(",")
              .map((el) => parseInt(el))
              .includes(e.id)
          );
        }
        Promise.all([this.beforeMountPromise, this.getCategoriesPromise]).then(
          () => {
            this.dateLoaded = true;
            this.redirect();
            this.disableCategories();
            this.updateActivitiesLayer();
          }
        );
      });

    this.map.getLeafletMap().on("draw:created", e => {
      this.stopDraw(e.layer);
    });
  },
  methods: {
    filterMap(from) {
      const categoryToFilter = this.categories.find(cat => cat.label === from);
      this.form.categories =
        categoryToFilter !== this.form.categories ? categoryToFilter : null;
      this.searchInMap();
    },
    redirect() {
      const route = {
        name: "MobilityQuery",
        params: {
          start: this.form.startDate
            ? this.form.startDate.join("_")
            : undefined,
          end: this.form.endDate ? this.form.endDate.join("_") : undefined
        },
        query: {
          employees:
            this.form.employees &&
            this.form.employees.length > 0 &&
            !this.form.employees.find(e => e.id === 0)
              ? this.form.employees.map(e => e.id).join(",")
              : undefined,
          categories:
            this.form.categories &&
            this.form.categories.length > 0 &&
            !this.form.categories.find(c => c.id === 0)
              ? this.form.categories.map(e => e.id).join(",")
              : undefined,
          activity: this.selectedFeatures
            ? this.selectedFeatures.map(feature => feature.id).join(",")
            : undefined,
          inBetweenSearch: this.form.inBetweenSearch
            ? this.form.inBetweenSearch
            : undefined,
          bbox: this.form.bbox ? this.form.bbox : undefined,
          advancedQueryTemporalRelation:
            this.form.advancedQueryTemporalRelation != null
              ? this.form.advancedQueryTemporalRelation
              : undefined,
          activityCat: this.form.advancedQueryCategory
            ? this.form.advancedQueryCategory
            : undefined,
          advancedQueryTimeComparation:
            this.form.advancedQueryTimeComparation != null
              ? this.form.advancedQueryTimeComparation
              : undefined,
          advancedQueryTime: this.form.advancedQueryTime
            ? this.form.advancedQueryTime
            : undefined
        }
      };
      if (
        JSON.stringify(this.$route.query) !== JSON.stringify(route.query) ||
        JSON.stringify(this.$route.params) !== JSON.stringify(route.params)
      ) {
        this.$router.replace(route);
      }
    },
    back() {
      this.selectedFeatures = this.backFeatures;
      this.detailComponent = this.backComponent;
    },
    showClientDetail(id, canGoBack) {
      this.backFeatures = canGoBack ? this.selectedFeatures : null;
      this.backComponent = canGoBack ? this.detailComponent : null;
      TrajectoryExploitationRepository.getClient(id)
        .then(data => {
          this.selectedFeatures = data;
          this.detailComponent = "client-detail";
        });
    },
    showEmployeeDetail(id, canGoBack) {
      this.backFeatures = canGoBack ? this.selectedFeatures : null;
      this.backComponent = canGoBack ? this.detailComponent : null;
      TrajectoryExploitationRepository.getEmployee(id)
        .then(data => {
          this.selectedFeatures = data;
          this.detailComponent = "employee-detail";
        });
    },
    showEventDetail(id, canGoBack) {
      this.backFeatures = canGoBack ? this.selectedFeatures : null;
      this.backComponent = canGoBack ? this.detailComponent : null;
      TrajectoryExploitationRepository.getEvent(id)
        .then(data => {
          this.selectedFeatures = data;
          this.detailComponent = "event-detail";
        });
    },
    close() {
      this.selectedFeatures = null;
      this.detailComponent = null;
      this.redirect();
      this.highlightItem(this.activitiesLayer, null, false);
    },
    setStyleHighlightedLayer(mainLayer, idFeature, highlight = true) {
      mainLayer.getLayer().then(layer => {
        // Setting highlighted color to the specified sublayer
        layer.eachLayer(subLayer => {
          if (subLayer.feature.id === idFeature) {
            let geoJsonStyle = highlightStyle(highlight, subLayer)
            if (geoJsonStyle instanceof L.DivIcon)
              subLayer.setIcon(geoJsonStyle);
            else subLayer.setStyle(geoJsonStyle);
          }
        });
      });
    },
    highlightItem(layer, ids, highlight = true) {
      // Remove last highlighted layer
      if (oldHighlightedIds) {
        oldHighlightedIds.forEach(id => {
          this.setStyleHighlightedLayer(
            layer,
            id,
            false
          );
        });
        oldHighlightedIds = null;
      }
      if (highlight) {
        ids.forEach(id => {
          this.setStyleHighlightedLayer(
            layer,
            id
          );
        })
        oldHighlightedIds = JSON.parse(JSON.stringify(ids));
      }
    },
    disableCategories() {
      if (this.form.categories.find(c => c.id > 0)) {
        this.categories.find(c => c.id === 0).disabled = true;
        this.form.categories = this.form.categories.filter(c => c.id !== 0);
      } else {
        this.categories.find(c => c.id === 0).disabled = false;
        if (this.form.categories.length === 0) {
          this.form.categories.push({
            id: 0,
            label: this.$t("trajectory_exploitation.allCategories")
          });
        }
      }
    },
    goTo(args) {
      switch (args.component) {
        case "employee":
          this.showEmployeeDetail(args.id, true);
          break;
        case "client":
          this.showClientDetail(args.id, true);
          break;
        case "event":
          this.showEventDetail(args.id, true);
          break;
      }
    },
    saveDate(prop, data) {
      this.form[prop] = data.date;
      if (this.form.startDate) {
        if (
          !this.form.endDate ||
          compareLocalDates(this.form.startDate, this.form.endDate) < 0
        ) {
          // Eliminates date picker errors
          this.$refs.startDate.setDatePickerErrorMessage(null);
          if (this.form.endDate) {
            this.$refs.endDate.setDatePickerErrorMessage(null);
          }
          this.searchInMap();
        } else {
          this.$notify({
            text: this.$t("trajectory_exploitation.endDateError"),
            type: "error"
          });
          this.$refs[prop].setDatePickerErrorMessage(
            this.$t("calendar.endTimeValidationError")
          );
        }
      }
    },
    searchInMap(from) {
      // Remove the detail component
      this.detailComponent = null;
      this.backFeatures = null;
      this.selectedFeatures = null;
      if (this.form.inBetweenSearch === 0) {
        this.form.endDate = null;
      }
      if (from === "checkBoxes.delimitZone") {
        if (this.drawing) {
          this.stopDraw();
        } else if (this.mapDelimiter) {
          this.mapDelimiter.removeFrom(this.map.getLeafletMap());
          this.form.bbox = null;
        }
      }
      if (from === "checkBoxes.advancedQueryCategory") {
        this.form.advancedQueryTemporalRelation = null;
        this.form.advancedQueryCategory = null;
      }
      if (from === "checkBoxes.advancedQueryTime") {
        this.form.advancedQueryTimeComparation = null;
        this.form.advancedQueryTime = null;
      }
      this.disableCategories();
      this.redirect();
      this.updateActivitiesLayer();
    },
    showActivityDetail(id) {
      this.selectedFeatures = [this.activities.find(a => a.id === id)];
      this.redirect();
      if (this.selectedFeatures != null) {
        this.detailComponent = "activity-detail";
        this.highlightItem(this.activitiesLayer, [id]);
      }
    },
    _getGeoJSONFeature(item) {
      let geoJSONFeature = {
        geometry: item.location ? item.location : item.geom,
        type: "Feature",
        id: item.id,
        properties: {}
      };
      if (item.category) {
        geoJSONFeature.properties["category_color"] = item.category.color;
      }
      return geoJSONFeature;
    },
    updateActivitiesLayer() {
      if (
        this.form.startDate &&
        (this.form.endDate || this.form.inBetweenSearch === 0) &&
        !this.advancedQueryCategoryError &&
        !this.advancedQueryTimeError &&
        !this.delimitZoneError
      ) {
        const employeesQuery = this.form.employees.filter(e => e.id !== 0);
        const categoriesQuery = this.form.categories.filter(c => c.id !== 0);

        const options = {
          params: {
            employee:
              employeesQuery.length > 0
                ? employeesQuery.map(e => e.id).join(",")
                : undefined,
            start: this.form.startDate
              ? localDateToISOString(this.form.startDate)
              : undefined,
            end: this.form.endDate
              ? localDateToISOString(this.form.endDate)
              : localDateToISOString(this.form.startDate),
            categories:
              categoriesQuery.length > 0
                ? categoriesQuery.map(c => c.id).join(",")
                : undefined,
            advancedQueryTemporalRelation:
              this.checkBoxes.advancedQueryCategory &&
              !this.advancedQueryCategoryError
                ? this.form.advancedQueryTemporalRelation
                : undefined,
            advancedQueryCategoryId:
              this.checkBoxes.advancedQueryCategory &&
              !this.advancedQueryCategoryError
                ? this.form.advancedQueryCategory
                : undefined,
            advancedQueryTimeComparation:
              this.checkBoxes.advancedQueryTime && !this.advancedQueryTimeError
                ? this.form.advancedQueryTimeComparation
                : undefined,
            advancedQueryTime:
              this.checkBoxes.advancedQueryTime && !this.advancedQueryTimeError
                ? this.form.advancedQueryTime
                : undefined,
            bbox:
              this.checkBoxes.delimitZone && !this.delimitZoneError
                ? this.form.bbox
                : undefined,
            delimitedZoneSearchType:
              this.checkBoxes.delimitZone && !this.delimitZoneError
                ? this.form.delimitedZoneSearchType
                : undefined
          }
        };

        TrajectoryExploitationRepository.getAllActivities(options)
          .then(data => {
            this.activities = data;

            updateLayer(this.activitiesLayer, this.activities, this._getGeoJSONFeature);

            this.activitiesLayer.getLayer().then(layer => {
              // Setting color of the sublayers depending on its category
              layer.eachLayer(subLayer => {
                subLayer.setStyle({
                  color: subLayer.feature.properties.category_color,
                  fillColor: subLayer.feature.properties.category_color,
                  opacity: 0.55,
                  fillOpacity:
                    subLayer.feature.geometry.type === "Point" ? 0.55 : 0
                });
              });
            });

            // If we received an activity id from the URL, we show the details of it
            if (this.form.activityId) {
              this.showActivityDetail(this.form.activityId);
              this.form.activityId = null;
            }
          });
      }
    },
    startDraw() {
      this.drawing = !this.drawing;
      if (this.drawing) {
        this.$refs.map.style.cursor = "pointer";
        if (this.mapDelimiter) {
          this.mapDelimiter.removeFrom(this.map.getLeafletMap());
          this.form.bbox = null;
        }
        this.mapDelimiter = new L.Draw.Polygon(this.map.getLeafletMap());
        this.mapDelimiter.enable();
      } else {
        this.stopDraw();
      }
    },
    stopDraw(geometry) {
      this.drawing = false;
      this.$refs.map.style.cursor = "grab";
      this.mapDelimiter.disable();
      if (geometry) {
        this.mapDelimiter = geometry;
      } else {
        this.mapDelimiter = null;
        return;
      }
      this.mapDelimiter.options.interactive = false;
      this.mapDelimiter.addTo(this.map.getLeafletMap());
      this.form.bbox = this.featureConversion(this.mapDelimiter);
      this.updateActivitiesLayer();
    },
    featureConversion(layer) {
      let wkt_poly = "POLYGON((";
      const latlngs = layer.getLatLngs();

      for (let i = 0; i <= latlngs[0].length; i++) {
        if (i !== 0) {
          wkt_poly += ",";
        }
        if (i === latlngs[0].length) {
          // We add the first point as the last, to fix a Leaflet Draw bug that doesn't close polygons correctly
          wkt_poly += latlngs[0][0].lng + " " + latlngs[0][0].lat;
        } else {
          wkt_poly += latlngs[0][i].lng + " " + latlngs[0][i].lat;
        }
      }
      wkt_poly += ")),/*%= data.basicData.SRID || 4326  %*/";
      return wkt_poly;
    }
  }
};
</script>

<style scoped>
#map {
  height: 52vh;
  z-index: 1;
}
.card {
  height: 52vh;
}
.employee-selector {
  max-width: 350px;
}
.title {
  margin-right: 12px;
  margin-left: 12px;
  margin-top: 6px;
  color: rgba(0, 0, 0, 0.87);
}
.title,
.advanced-query-title {
  margin-top: 4px;
}
@media (max-width: 992px) {
  .card {
    height: auto;
  }
  #map {
    height: 55vh;
    z-index: 1;
  }
}
#click-on-activity-label {
  color: lightslategray;
  font-size: 20px;
}
</style>

/*% } %*/
