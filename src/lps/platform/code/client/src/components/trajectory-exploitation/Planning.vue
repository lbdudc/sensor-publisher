/*% if (feature.MWM_TE_Planning) { %*/
<template>
  <v-container fluid>
    <v-row no-gutters class="mt-1">
      <label class="headline custom-title">
        {{ $t("trajectory_exploitation.planningView") }}
      </label>
      <autocomplete
        v-model="form.employee"
        class="custom-autocomplete"
        :label="$t('trajectory_exploitation.employee')"
        :items="employees"
        item-text="fullName"
        item-value="id"
        @change="searchInMap('employees')"
        return-object
        solo
        dense
      ></autocomplete>
      <label class="headline custom-title ml-3">
        {{ $t("trajectory_exploitation.for") }}
      </label>
      <autocomplete
        v-model="form.client"
        class="custom-autocomplete"
        :label="$t('trajectory_exploitation.allClients')"
        :items="clients"
        item-text="fullName"
        item-value="id"
        @change="searchInMap('client')"
        return-object
        solo
        dense
      ></autocomplete>
    </v-row>
    <v-row no-gutters>
      <v-col cols="12" md="6" ref="mapContainer">
        <v-row no-gutters>
          <v-col cols="12">
            <v-container class="pr-0" ref="map" id="map"></v-container>
          </v-col>
        </v-row>
      </v-col>
      <v-col cols="12" md="6" class="pl-md-2">
        <v-row no-gutters class="mt-3 mt-md-0">
          <v-col>
            <v-card class="pl-lg-5 pl-3 card">
              <component
                :is="detailComponent"
                :features="selectedFeature"
                :visits="visits"
                :canClose="true"
                @close="closeDetails"
                @click-visit="onClickVisit"
                v-if="detailComponent && visits.length > 0"
              ></component>
              <v-container fill-height v-if="(detailComponent && (!visits || visits.length == 0)) || !detailComponent">
                <v-row class="text-center" justify="center">
                  <v-col cols="12">
                    <label id="no-visits-label"> {{ detailComponent ? $t("trajectory_exploitation.noPlannedVisits") : $t("trajectory_exploitation.oneEmpOrCliMin") }} </label>
                  </v-col>
                </v-row>
              </v-container>
            </v-card>
          </v-col>
        </v-row>
      </v-col>
    </v-row>
  </v-container>
</template>

<script>
import { formatDateInverse } from "@/common/conversion-utils";
import initMap from "@/common/initMap";
import updateLayer from "./utils/updateLayer";
import ClientDetail from "./details/ClientDetail";
import EventDetail from "./details/EventDetail";
import EmployeeDetail from "./details/EmployeeDetail";
import VisitList from "./details/VisitList";
import Autocomplete from "@/components/debouncing-inputs/Autocomplete.vue";
import RepositoryFactory from "@/repositories/RepositoryFactory";
const TrajectoryExploitationRepository = RepositoryFactory.get("TrajectoryExploitationRepository");
const colors = {
  visits: {
    DONE: "#97ef15",
    PENDING: "#fac32f"
  }
};
const icons = {
  anchor: {
    highlighted: [33, 53],
    normal: [20, 45]
  },
  sizes: {
    highlighted: 35,
    normal: 30
  },
  employees: require("../../assets/icon_employee.png"),
  visits: require("../../assets/icon_visits.png")
}
// This function returns an HTML string that contains the icon that ...
// ... represents a visit and the label that indicates its order
const _getVisitsIconHTML = (order, color, highlight) => {
  const iconSize = highlight
    ? icons.sizes.highlighted
    : icons.sizes.normal;
  const orderLabelSize = highlight ? 55 : icons.sizes.normal;
  const iconUrl = icons.visits;
  // HTML that contains the icon
  let imgHTML =
    "<img style='height: " +
    iconSize +
    "px; width: " +
    iconSize +
    "px;' src='" +
    iconUrl +
    "'/>";
  // Add a red circle around the icon if it is highlighted
  if (highlight) {
    imgHTML = "<div id='red-circle'>" + imgHTML + "</div>";
  }
  return (
    "<div style='text-align: center; width:" +
    orderLabelSize +
    "px'><div style='border-radius: 200px 200px 200px 200px; background-color:" +
    color +
    "; width: 20px; margin: 0 auto;'>" +
    "<span style='font-size: 15px;'>" +
    order +
    "</span>" +
    "</div></div>" +
    imgHTML
  );
};
const highlightStyle = (highlight, subLayer) => {
  const color = colors.visits[subLayer.feature.properties.state];
  const iconAnchor = highlight
    ? icons.anchor.highlighted
    : icons.anchor.normal;
  // Icon for visit
  return new L.divIcon({
    iconAnchor: iconAnchor,
    className: "",
    html: _getVisitsIconHTML(
      subLayer.feature.properties.order,
      color,
      highlight
    )
  });
};
var oldHighlightedIds = null;

export default {
  name: "Planning",
  data() {
    return {
      form: {
        employee: null,
        startDate: null,
        endDate: null,
        client: null,
        visit: null
      },
      map: null,
      detailComponent: null,
      selectedFeature: null,
      employees: [],
      clients: [],
      visits: [],
      employeesLayer: null,
      visitsLayer: null,
      routesLayer: null,
      showFilters: true,
      isMobile: null
    };
  },
  components: {
    VisitList,
    Autocomplete,
    "client-detail": ClientDetail,
    "employee-detail": EmployeeDetail,
    "visit-detail": EventDetail,
    "visit-list": VisitList
  },
  beforeMount() {
    /*
    this.form.startDate = this.$route.params.start
      ? parseInt(this.$route.params.start)
      : null;
    this.form.endDate = this.$route.params.end
      ? parseInt(this.$route.params.end)
      : null;
    */
    // Setting current day
    let currentDate = new Date();
    currentDate = new Date(
      currentDate.getFullYear(),
      currentDate.getMonth(),
      currentDate.getDate(),
      0,
      0,
      0
    );
    this.form.startDate = currentDate.getTime();
    this.form.endDate = currentDate.getTime();
  },
  mounted() {
    this.map = initMap("map", "planning", [
      [41.508742458803326, -4.087890625],
      [44.508742458803326, -12.087890625],
    ]);

    const employeesLayerStyle = new MV.GeoJSONLayerStyle("employees_style", {
      icon: {
        iconUrl: icons.employees,
        iconSize: [30, 30],
        iconAnchor: [15, 15],
      },
    });

    // Creating empty employees layer
    this.employeesLayer = new MV.GeoJSONLayer(
      {
        type: "FeatureCollection",
        features: [],
      },
      {
        id: "employees-location",
        label: "employees-location",
        baseLayer: false
      },
      [employeesLayerStyle],
      employeesLayerStyle
    );

    this.map.addLayer(this.employeesLayer);

    const visitsLayerStyle = new MV.GeoJSONLayerStyle("visits_style", {
      icon: {
        iconUrl: icons.visits,
        iconSize: icons.sizes.normal,
        iconAnchor: icons.anchor.normal,
      },
    });

    // Creating empty visits layer
    this.visitsLayer = new MV.GeoJSONLayer(
      {
        type: "FeatureCollection",
        features: [],
      },
      {
        id: "visit-geom",
        label: "visit-geom",
        baseLayer: false,

        // Showing GeoJSON info
        click: (visit) => this.callbackGeoJSONVisit(visit.layer.feature.id),
      },
      [visitsLayerStyle],
      visitsLayerStyle
    );

    this.map.addLayer(this.visitsLayer);

    const routesLayerStyle = new MV.GeoJSONLayerStyle("routes_style", {
      color: colors.visits,
      opacity: 0.55,
    });

    // Creating empty routes layer
    this.routesLayer = new MV.GeoJSONLayer(
      {
        type: "FeatureCollection",
        features: [],
      },
      {
        id: "route-geom",
        label: "route-geom",
        baseLayer: false,

        // Showing GeoJSON info
        click: (visit) => this.callbackGeoJSONVisit(visit.layer.feature.id),
      },
      [routesLayerStyle],
      routesLayerStyle
    );

    this.map.addLayer(this.routesLayer);

    // Getting all the employees and calling to update employees layer to represent the selected one
    TrajectoryExploitationRepository.getAllEmployees()
      .then((data) => {
        this.employees = data;
        if (this.$route.query.employee != null) {
          this.form.employee = this.employees.find(
            (e) => this.$route.query.employee === e.id
          );
        }
        if (this.$route.query.visit != null) {
          this.form.visit = this.$route.query.visit;
        }
        // Getting clients
        this.updateClientsList().then(() => {
          if (this.$route.query.client != null) {
            this.form.client = this.clients.find(
              (c) => this.$route.query.client === c.id
            );
          }
          this.updateEmployeesLayer();
          this.updateVisitsLayer();
        });
      });
  },
  methods: {
    redirect() {
      const query = {
        employee: this.form.employee
          ? this.form.employee.id.toString()
          : undefined,
        client: this.form.client ? this.form.client.id.toString() : undefined,
        visit: this.form.visit ? this.form.visit.toString() : undefined
      };
      if (
        JSON.stringify(this.$router.currentRoute.query) !== JSON.stringify(query)
      ) {
        this.$router.replace({
          name: "Planning",
          query: query
        });
      }
    },
    closeDetails() {
      this.highlightItem(this.visitsLayer, [this.selectedFeature.id], false);
      this.detailComponent = this.form.employee ? "visit-list" : null;
      this.selectedFeature = null;
      this.form.visit = null;
      this.form.client = null;
      this.searchInMap();
    },
    saveStartDate(newDate) {
      this.form.startDate = newDate;
      if (!this.form.endDate || newDate <= this.form.endDate) {
        this.redirect();
        this.updateVisitsLayer();
      } else {
        this.$notify({
          text: this.$t("trajectory_exploitation.startDateError"),
          type: "error"
        });
      }
    },
    saveEndDate(newDate) {
      this.form.endDate = newDate;
      if (!this.form.startDate || this.form.startDate <= newDate) {
        this.redirect();
        this.updateVisitsLayer();
      } else {
        this.$notify({
          text: this.$t("trajectory_exploitation.endDateError"),
          type: "error"
        });
      }
    },
    onClickVisit(visitId) {
      this.form.visit = visitId;
      this.updateVisitsLayer();
      this.redirect();
    },
    searchInMap(from) {
      // Remove the detail component and the visit detailed
      this.detailComponent = null;
      this.form.visit = null;
      // Unhighlight all features in visitsLayer
      this.highlightItem(this.visitsLayer, null, false);

      if (from == "employees") {
        this.form.client = null;
        this.updateEmployeesLayer();
      }
      this.updateVisitsLayer();
      this.redirect();
    },
    callbackGeoJSONVisit(id) {
      this.form.visit = id;
      this.updateVisitsLayer();
    },
    _getGeoJSONFeature(item) {
      let geoJSONFeature = {
        geometry: item.location ? item.location : item.geom,
        type: "Feature",
        id: item.id,
        /*% if (feature.MVM_VT_OnlyDay) { %*/
        properties: {
          order: item.eventOrder
        }
        /*% } else { %*/
        properties: {
          order: item.startTime ? this.visits.findIndex(v => v.id == item.id) + 1 : undefined
        }
        /*% } %*/
      };
      if (item.state) {
        geoJSONFeature.properties["state"] = item.state;
      }
      return geoJSONFeature;
    },
    updateLayerAndBindTooltip(receivedLayer, list) {
      updateLayer(receivedLayer, list, this._getGeoJSONFeature);
      // Attach tooltip to each employee/client icon
      receivedLayer.getLayer().then(layer => {
        layer.eachLayer(subLayer => {
          const item = list.find(item => item.id == subLayer.feature.id);
          subLayer.bindTooltip(
            item.fullName ? item.fullName : item.client.fullName
          );
        });
      });
    },
    updateRouteLayer(routeLayer, visitsList) {
      routeLayer.getLayer().then(layer => {
        let idsMap = [];
        layer.eachLayer(subLayer => {
          if (!visitsList.find(e => e.id == subLayer.feature.id)) {
            layer.removeLayer(subLayer._leaflet_id);
          } else {
            idsMap.push(subLayer.feature.id);
          }
        });
        visitsList.forEach(item => {
          if (!idsMap.includes(item.id)) {
            layer.addData({
              geometry: item.route,
              type: "Feature",
              id: item.id,
              properties: {
                state: item.state
              }
            });
          }
        });
      });
    },
    updateEmployeesLayer() {
      // Adapter to use the generic updateLayer function
      const auxList = this.form.employee ? [this.form.employee] : [];
      this.updateLayerAndBindTooltip(this.employeesLayer, auxList);
    },
    updateVisitsLayer() {
      // If there is no selected employees, delete all the visits from the map
      if (this.form.employee || this.form.client || this.form.visit) {
        const options = {
          params: {
            start: formatDateInverse(this.form.startDate),
            end: formatDateInverse(this.form.endDate),
            employee: this.form.employee ? this.form.employee.id : null
          }
        };
        TrajectoryExploitationRepository.getAllEvents(options)
          .then(data => {
            this.visits = data;

            // If we have a visit selected, we show the details of this one
            //  else if we have a client selected, we show the details of the first visit to that client
            let clientVisit = null;
            if (this.form.visit) {
              clientVisit = this.visits.find(e => e.id === this.form.visit);
              if (!clientVisit) {
                this.$notify({
                  text: this.$t("trajectory_exploitation.visitNotExists"),
                  type: "error"
                });
                this.form.visit = null;
                this.redirect();
                return;
              }
              this.form.employee = clientVisit.employee;
              this.form.client = clientVisit.client;
            } else if (this.form.client != null) {
              clientVisit = this.visits.find(
                e => e.client.id === this.form.client.id
              );
            }

            if (clientVisit) {
              this.selectedFeature = clientVisit;
              this.form.employee = this.selectedFeature.employee;
              this.form.visit = this.selectedFeature.id;
              this.detailComponent = "visit-detail";
              this.visits = this.visits.filter(
                visit => visit.employee.id === this.form.employee.id
              );
              this.updateEmployeesLayer();
              this.redirect();
            }

            // Load clients list
            this.clients = this.visits.map(visit => visit.client);

            this.updateLayerAndBindTooltip(this.visitsLayer, this.visits);
            this.updateRouteLayer(this.routesLayer, this.visits);

            this.setVisitIcons();
            this.setLayerStyle(this.routesLayer, colors.visits);

            // If there is the details view opened, highlight the detailed visit
            if (this.detailComponent && this.detailComponent !== "visit-list") {
              this.highlightItem(this.visitsLayer, [this.selectedFeature.id]);
            }

            // If there is no details view opened and an employee is selected, we show employee's visit list
            if (!this.detailComponent && this.form.employee) {
              this.detailComponent = "visit-list";
            }

            // Focus on employee + visits markers
            this.employeesLayer.getBounds().then(employeesBounds => {
              this.visitsLayer.getBounds().then(visitsBounds => {
                if (employeesBounds.isValid() && visitsBounds.isValid()) {
                  this.map.centerView(
                    visitsBounds.extend(employeesBounds).pad(0.2)
                  );
                }
              });
            });
          });
      } else {
        this.visitsLayer.getLayer().then(layer => {
          layer.eachLayer(subLayer => {
            layer.removeLayer(subLayer._leaflet_id);
          });
        });
        this.routesLayer.getLayer().then(layer => {
          layer.eachLayer(subLayer => {
            layer.removeLayer(subLayer._leaflet_id);
          });
        });
        this.updateClientsList();
      }
    },
    updateClientsList() {
      const options = {
        params: {
          start: formatDateInverse(this.form.startDate),
          end: formatDateInverse(this.form.endDate),
          employee: this.form.employee ? this.form.employee.id : null
        }
      };
      return TrajectoryExploitationRepository.getAllEvents(options)
        .then(data => {
          this.clients = data
            .map(visit => visit.client)
            .sort(function(a, b) {
              if (a.fullName > b.fullName) {
                return 1;
              } else if (a.fullName < b.fullName) {
                return -1;
              } else {
                return 0;
              }
            });
        });
    },
    setLayerStyle(mainLayer, colors) {
      mainLayer.getLayer().then(layer => {
        // Setting color of the sublayers depending on its state
        layer.eachLayer(subLayer => {
          subLayer.setStyle({
            color: colors[subLayer.feature.properties.state],
            fillColor: colors[subLayer.feature.properties.state],
            opacity: 0.55
          });
        });
      });
    },
    setStyleHighlightedLayer(mainLayer, idFeature, highlight = true) {
      mainLayer.getLayer().then(layer => {
        // Setting highlighted color to the specified sublayer
        layer.eachLayer(subLayer => {
          if (subLayer.feature.id === idFeature) {
            let geoJsonStyle = highlightStyle(highlight, subLayer)
            if (geoJsonStyle instanceof L.DivIcon)
              subLayer.setIcon(geoJsonStyle);
            else subLayer.setStyle(geoJsonStyle);
          }
        });
      });
    },
    highlightItem(layer, ids, highlight = true) {
      // Remove last highlighted layer
      if (oldHighlightedIds) {
        oldHighlightedIds.forEach(id => {
          this.setStyleHighlightedLayer(
            layer,
            id,
            false
          );
        });
        oldHighlightedIds = null;
      }
      if (highlight) {
        ids.forEach(id => {
          this.setStyleHighlightedLayer(
            layer,
            id
          );
        })
        oldHighlightedIds = JSON.parse(JSON.stringify(ids));
      }
    },
    setVisitIcons() {
      this.visitsLayer.getLayer().then(layer => {
        // Setting icon of the sublayers depending on visit state
        layer.eachLayer(subLayer => {
          subLayer.setIcon(
            new L.divIcon({
              iconAnchor: icons.anchor.normal,
              className: "",
              html: _getVisitsIconHTML(
                subLayer.feature.properties.order,
                colors.visits[subLayer.feature.properties.state],
                false
              )
            })
          );
        });
      });
    }
  }
};
</script>
<style scoped>
#map {
  height: 80vh;
  z-index: 1;
}
.custom-title {
  margin-right: 10px;
  margin-top: 6px;
}
.card {
  height: 80vh;
}
>>> #red-circle {
  border-radius: 200px 200px 200px 200px;
  border: 2px solid red;
  display: inline-flex;
  width: 55px;
  height: 55px;
  padding: 6px 0 0 8px;
}
@media (max-width: 992px) {
  .card {
    height: auto;
  }
  #map {
    height: 55vh;
    z-index: 1;
  }
}
#no-visits-label {
  color: lightslategray;
  font-size: 20px;
}
</style>
/*% } %*/
