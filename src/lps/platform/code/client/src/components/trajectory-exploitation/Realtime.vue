/*% if (feature.MWM_TE_Realtime) { %*/
<template>
  <v-container fluid>
    <v-row class="mt-1" no-gutters>
      <v-col cols="6" class="d-none d-md-block">
        <span class="headline no-split-words">
          {{ $t($route.meta.label) }}
        </span>
      </v-col>
      <v-col cols="12" md="6">
        <v-row class="justify-end" no-gutters>
          <v-col cols="12" sm="5" class="mt-2 mr-2 text-center text-sm-right">
            <label>
              {{ $t("trajectory_exploitation.employeeFinder") }}
            </label>
          </v-col>
          <v-col cols="12" sm="6" style="display: contents">
            <autocomplete
              id="autocomplete-employee"
              v-model="employee"
              class="d-sm-block"
              :label="$t('trajectory_exploitation.employee')"
              :items="employees"
              item-text="fullName"
              item-value="id"
              @change="searchInMap"
              return-object
              dense
              solo
            ></autocomplete>
          </v-col>
        </v-row>
      </v-col>
    </v-row>
    <v-row no-gutters>
      <v-col cols="12" md="6" ref="mapContainer">
        <v-row no-gutters>
          <v-col cols="12">
            <v-container class="pr-0" ref="map" id="map"></v-container>
          </v-col>
        </v-row>
      </v-col>
      <v-col cols="12" md="6" class="pl-md-2">
        <v-card class="pl-md-5 card">
          <employee-detail
            v-if="employee"
            :features="employee"
          ></employee-detail>
          <visit-list :visits="events" v-if="employee && events"> </visit-list>
          <v-container fill-height v-if="!employee">
            <v-row class="text-center" justify="center">
              <v-col cols="12">
                <v-label id="no-employee-label">
                  {{ $t("trajectory_exploitation.selectEmployee") }}
                </v-label>
              </v-col>
            </v-row>
          </v-container>
        </v-card>
      </v-col>
    </v-row>
  </v-container>
</template>

<script>
import { formatDateInverse } from "@/common/conversion-utils";
import updateLayer from "./utils/updateLayer";
import initMap from "@/common/initMap";
import EmployeeDetail from "./details/EmployeeDetail";
import VisitList from "./details/VisitList";
import Autocomplete from "@/components/debouncing-inputs/Autocomplete.vue";
import RepositoryFactory from "@/repositories/RepositoryFactory";
const TrajectoryExploitationRepository = RepositoryFactory.get(
  "TrajectoryExploitationRepository"
);
// This function returns an HTML string that contains the icon that represents an employee
const _getEmployeeIconHTML = (highlight) => {
  const iconSize = highlight ? 45 : 30;
  const iconUrl = require("../../assets/icon_employee.png");
  // HTML that contains the icon
  let imgHTML =
    "<img style='height: " +
    iconSize +
    "px; width: " +
    iconSize +
    "px;' src='" +
    iconUrl +
    "'/>";
  // Add a red circle around the icon if it is highlighted
  if (highlight) {
    imgHTML = "<div id='red-circle'>" + imgHTML + "</div>";
  }
  return imgHTML;
};
const highlightStyle = (highlight) => {
  // Icon for employee
  return new L.divIcon({
    iconAnchor: highlight ? [28, 27] : [15, 15],
    className: "",
    html: _getEmployeeIconHTML(highlight),
  });
};
var oldHighlightedIds = null;

export default {
  name: "Realtime",
  data() {
    return {
      employee: null,
      map: null,
      employees: [],
      events: [],
      intervalId: null,
      employeesLayer: null,
    };
  },
  components: {
    VisitList,
    Autocomplete,
    "employee-detail": EmployeeDetail,
  },
  beforeDestroy() {
    localStorage.setItem(
      "trajectory-exploitation-state",
      JSON.stringify(this.map.exportState())
    );
    window.clearInterval(this.intervalId);
  },
  mounted() {
    this.map = initMap("map", "realtime", [
      [41.508742458803326, -4.087890625],
      [44.508742458803326, -12.087890625],
    ]);

    const employeesLayerStyle = new MV.GeoJSONLayerStyle("employee_style", {
      icon: {
        iconUrl: require("../../assets/icon_employee.png"),
        iconSize: [30, 30],
        iconAnchor: [15, 15],
      },
    });

    // Creating empty employees layer represented by an icon
    this.employeesLayer = new MV.GeoJSONLayer(
      {
        type: "FeatureCollection",
        features: [],
      },
      {
        id: "employees-location",
        label: "employees-location",
        baseLayer: false,
        // Showing GeoJSON info
        click: (event) => {
          // If you click on the same item, it does nothing
          if (!this.employee || this.employee.id !== event.layer.feature.id) {
            this.employee = this.employees.find(
              (emp) => emp.id == event.layer.feature.id
            );
            this.searchInMap();
          }
        },
      },
      [employeesLayerStyle],
      employeesLayerStyle
    );

    this.map.addLayer(this.employeesLayer);

    if (localStorage.getItem("trajectory-exploitation-state")) {
      setTimeout(() => {
        this.map.importState(
          JSON.parse(localStorage.getItem("trajectory-exploitation-state"))
        );
        localStorage.removeItem("trajectory-exploitation-state");
      }, 100);
    }

    this.updateEmployeesLayer().then(() => {
      // Focus on employee markers
      this.employeesLayer.getBounds().then((bounds) => {
        if (bounds.isValid()) {
          this.map.centerView(bounds.pad(0.2));
        }
      });
      if (this.$route.query.employee) {
        this.employee = this.employees.find(
          (e) => e.id == this.$route.query.employee
        );
        this.searchInMap();
      }
    });

    // The position of the employees is updated every 30 SECONDS
    this.intervalId = window.setInterval(() => {
      this.updateEmployeesLayer().then(() => {
        if (this.$route.query.employee) {
          this.highlightItem(this.employeesLayer, [this.$route.query.employee]);
        }
      });
    }, 30000);
  },
  methods: {
    _getGeoJSONFeature(item) {
      let geoJSONFeature = {
        geometry: item.location,
        type: "Feature",
        id: item.id,
      };
      return geoJSONFeature;
    },
    updateEmployeesLayer() {
      return new Promise((resolve) => {
        TrajectoryExploitationRepository.getAllEmployees()
          .then((data) => {
            this.employees = data;
            updateLayer(
              this.employeesLayer,
              this.employees,
              this._getGeoJSONFeature
            );

            // Attach popup to each employee's icons
            this.employeesLayer.getLayer().then((layer) => {
              // Attach tooltip to each employee/client icon
              layer.eachLayer((subLayer) => {
                const employee = this.employees.find(
                  (emp) => emp.id === subLayer.feature.id
                );
                subLayer.bindTooltip(employee.fullName);
              });
            });

            resolve();
          });
      });
    },
    setStyleHighlightedLayer(mainLayer, idFeature, highlight = true) {
      mainLayer.getLayer().then((layer) => {
        // Setting highlighted color to the specified sublayer
        layer.eachLayer((subLayer) => {
          if (subLayer.feature.id === idFeature) {
            const geoJsonStyle = highlightStyle(highlight, subLayer);
            if (geoJsonStyle instanceof L.DivIcon)
              subLayer.setIcon(geoJsonStyle);
            else subLayer.setStyle(geoJsonStyle);
          }
        });
      });
    },
    highlightItem(layer, ids, highlight = true) {
      // Remove last highlighted layer
      if (oldHighlightedIds) {
        oldHighlightedIds.forEach((id) => {
          this.setStyleHighlightedLayer(layer, id, false);
        });
        oldHighlightedIds = null;
      }
      if (highlight) {
        ids.forEach((id) => {
          this.setStyleHighlightedLayer(layer, id);
        });
        oldHighlightedIds = JSON.parse(JSON.stringify(ids));
      }
    },
    searchInMap() {
      let query = this.employee
        ? { employee: this.employee.id.toString() }
        : {};
      if (JSON.stringify(this.$route.query) != JSON.stringify(query)) {
        this.$router.replace({
          path: "realtime",
          query: query,
        });
      }
      let isEmptyQuery = JSON.stringify(query) != JSON.stringify({});
      // Unhighlight the last item highlighted and if the query is not empty highlight the item selected
      this.highlightItem(
        this.employeesLayer,
        this.employee ? [this.employee.id] : null,
        isEmptyQuery
      );
      // Show employee detail if query is not empty
      if (isEmptyQuery)
        this.showEmployeeDetails(this.employee ? this.employee.id : null);
    },
    showEmployeeDetails(employeeId) {
      const dateString = formatDateInverse(new Date());
      const options = {
        params: {
          employee: employeeId,
          start: dateString,
          end: dateString,
        },
      }
      TrajectoryExploitationRepository.getAllEvents(options)
        .then(
          (eventsData) =>
            (this.events = eventsData.sort((a, b) => a.startTime - b.endTime))
        );
    },
  },
};
</script>
<style scoped>
#map {
  height: 80vh;
  z-index: 1;
}
.card {
  height: 80vh;
}
>>> #red-circle {
  border-radius: 200px 200px 200px 200px;
  border: 2px solid red;
  display: inline-flex;
  width: 55px;
  height: 55px;
  padding: 3px 0 0 4px;
}
@media (max-width: 992px) {
  .card {
    height: auto;
  }
  #map {
    height: 55vh;
    z-index: 1;
  }
}
#no-employee-label {
  color: lightslategray;
  font-size: 20px;
}
#autocomplete-employee {
  display: inherit;
  max-width: 300px;
}
</style>
/*% } %*/
