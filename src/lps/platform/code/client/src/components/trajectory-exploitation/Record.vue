/*% if (feature.MWM_TE_ActivitiesRecord) { %*/
<template>
  <v-container fluid>
    <v-row no-gutters class="mt-1">
      <label class="headline custom-title ml-0">
        {{ $t("trajectory_exploitation.activityHistory") }}
      </label>
      <v-select
        v-model="form.searchType"
        class="custom-select"
        item-text="label"
        item-value="id"
        :items="searchTypes"
        :menu-props="{ offsetY: true }"
        @change="searchInMap('searchType')"
        dense
        solo
      ></v-select>
      <v-col class="date-picker-container mt-2">
        <dateAndHourPicker
          :datePickerProp="{
            data: form.startDate,
            label:
              form.searchType == 1
                ? $t('trajectory_exploitation.date')
                : $t('trajectory_exploitation.startDate'),
            mandatory: true
          }"
          @update-time="saveDate('startDate', ...arguments)"
          ref="startDate"
          v-if="dateLoaded"
        ></dateAndHourPicker>
      </v-col>
      <label class="headline custom-title" v-show="form.searchType != 1">
        {{ $t("trajectory_exploitation.and") }}
      </label>
      <v-col
        class="date-picker-container mt-2"
        v-if="form.searchType != 1 && dateLoaded"
      >
        <dateAndHourPicker
          :datePickerProp="{
            data: form.endDate,
            label: $t('trajectory_exploitation.endDate'),
            mandatory: true
          }"
          ref="endDate"
          @update-time="saveDate('endDate', ...arguments)"
        ></dateAndHourPicker>
      </v-col>
      <label class="headline custom-title">
        {{ $t("trajectory_exploitation.by") }}
      </label>
      <v-col cols="12" md="4" class="pt-1">
        <autocomplete
          v-model="form.employees"
          :label="$t('trajectory_exploitation.employeesLabel')"
          :items="employees"
          item-text="fullName"
          :error="employeesError"
          return-object
          multiple
          @change="searchInMap('employees')"
          dense
          solo
          abreviate
          select-all
        >
        </autocomplete>
      </v-col>
      <v-col class="mt-3 ml-2" v-if="showWarning">
        <v-icon color="red" @click="warningDialog = true">
          report_problem
        </v-icon>
      </v-col>
    </v-row>
    <v-row no-gutters>
      <v-col cols="12" md="6" ref="mapContainer">
        <v-container ref="map" id="map"></v-container>
      </v-col>
      <v-col cols="12" md="6" class="pl-md-2 pt-2 pt-md-0 pb-0">
        <v-card class="pl-lg-5 pl-3 card">
          <component
            :is="detailComponent"
            :features="selectedFeatures"
            :canGoBack="backFeatures != null"
            :canClose="true"
            @close="close"
            @back="back"
            @go-to="goTo"
            v-if="detailComponent && selectedFeatures"
          ></component>
          <v-container fill-height v-if="!detailComponent">
            <v-row class="text-center" justify="center">
              <v-col cols="12">
                <label id="click-on-activity-label">
                  {{ $t("trajectory_exploitation.clickOnActivity") }}
                </label>
              </v-col>
            </v-row>
          </v-container>
        </v-card>
      </v-col>
    </v-row>
    <v-row>
      <v-col cols="12">
        <v-card>
          <v-row no-gutters>
            <v-col class="pl-5 pt-2">
              <label class="legend-label">
                {{ $t("trajectory_exploitation.record.statistics") }}
              </label>
            </v-col>
          </v-row>
          <v-row class="mx-5" no-gutters>
            <v-col class="text-center">
              <statistics-table
                :statistics-data="statisticsData"
                :sortable="false"
                :hideFooter="false"
                ref="statisticsTable"
                @filter="filterMap"
                v-on:created="tablePromiseResolve()"
                class="pt-0"
              ></statistics-table>
            </v-col>
          </v-row>
        </v-card>
      </v-col>
    </v-row>
    <modal-dialog
      @cancel="warningDialog = false"
      :dialog="warningDialog"
      :title="$t('trajectory_exploitation.warning_dialog.title')"
      titleClass="warning white--text"
      titleIcon="warning"
      :cancel-text="$t('trajectory_exploitation.warning_dialog.Close')"
      :content="$t('trajectory_exploitation.warning_dialog.content')"
    ></modal-dialog>
  </v-container>
</template>

<script>
import initMap from "@/common/initMap";
import updateLayer from "./utils/updateLayer";
import { localDateToISOString } from "@/common/conversion-utils";
import { compareLocalDates } from "@/common/comparation-utils";
import ClientDetail from "./details/ClientDetail";
import EventDetail from "./details/EventDetail";
import DateAndHourPicker from "../calendar/DateAndHourPicker";
import EmployeeDetail from "./details/EmployeeDetail";
import ActivityDetail from "./details/ActivityDetail";
import StatisticsTable from "./ActivityStatisticsTable";
import Autocomplete from "@/components/debouncing-inputs/Autocomplete.vue";
import RepositoryFactory from "@/repositories/RepositoryFactory";
import ModalDialog from "@/components/modal_dialog/ModalDialog";
const TrajectoryExploitationRepository = RepositoryFactory.get(
  "TrajectoryExploitationRepository"
);
const highlightStyle = (highlight, subLayer) => {
  const HIGHLIGHT_COLOR = "#FFFF00";
  return {
    color: highlight
      ? HIGHLIGHT_COLOR
      : subLayer.feature.properties.category_color,
    fillColor: highlight
      ? HIGHLIGHT_COLOR
      : subLayer.feature.properties.category_color,
    fillOpacity:
      subLayer.feature.geometry.type == "Point"
        ? highlight
          ? 1.0
          : 0.55
        : 0,
    opacity: highlight ? 1.0 : 0.55
  }
};
var oldHighlightedIds = null;

export default {
  name: "Record",
  data() {
    return {
      backFeatures: null,
      backComponent: null,
      selectedFeatures: null,
      detailComponent: null,
      form: {
        employees: [],
        startDate: null,
        endDate: null,
        category: null,
        searchType: 1,
        activityId: null
      },
      isLoading: true,
      map: null,
      statisticsData: [],
      employeesError: false,
      employees: [],
      activities: [],
      categories: null,
      activitiesLayer: null,
      showLegend: true,
      searchTypes: [
        { id: 1, label: this.$t("trajectory_exploitation.in") },
        { id: 2, label: this.$t("trajectory_exploitation.between") }
      ],
      beforeMountPromise: null,
      getCategoriesPromise: null,
      tablePromise: null,
      tablePromiseResolve: null,
      dateLoaded: false, // Prevents date picker from loading empty
      showWarning: false,
      warningDialog: false
    };
  },
  components: {
    ModalDialog,
    StatisticsTable,
    DateAndHourPicker,
    Autocomplete,
    "client-detail": ClientDetail,
    "employee-detail": EmployeeDetail,
    "event-detail": EventDetail,
    "activity-detail": ActivityDetail
  },
  beforeMount() {
    this.form.searchType = this.$route.query.searchType
      ? parseInt(this.$route.query.searchType)
      : 1;

    this.form.activities = this.$route.query.activities
      ? this.$route.query.activities.split(",")
      : null;

    this.beforeMountPromise = new Promise(resolve => {
      if (this.$route.params.start) {
        this.form.startDate = this.$route.params.start
          .split("_")
          .map(str => parseInt(str));
        if (this.form.searchType == 2 && this.$route.params.end) {
          this.form.endDate = this.$route.params.end
            .split("_")
            .map(str => parseInt(str));
        }
        this.dateLoaded = true;
        resolve();
      } else {
        TrajectoryExploitationRepository.getLastDay()
          .then(data => {
            this.form.startDate = data.map(str => parseInt(str));
            if (this.form.searchType === 2) {
              this.form.endDate = data.map(str => parseInt(str));
            }
            this.dateLoaded = true;
            resolve();
          });
      }
    });

    this.getCategoriesPromise = new Promise(resolve => {
      TrajectoryExploitationRepository.getAllActivityCategories().then(data => {
        this.categories = data;
        this.form.category = this.categories.find(
          c => c.id === this.$route.query.category
        );
        resolve();
      });
    });
    this.tablePromise = new Promise(resolve => {
      this.tablePromiseResolve = resolve;
    });
  },
  mounted() {
    this.map = initMap("map", "record", [
      [41.508742458803326, -4.087890625],
      [44.508742458803326, -12.087890625]
    ]);

    // Creating empty activities layer
    this.activitiesLayer = new MV.GeoJSONLayer(
      {
        type: "FeatureCollection",
        features: []
      },
      {
        id: "activities-geom",
        label: "activities-geom",
        baseLayer: false
      }
    );
    this.map.addLayer(this.activitiesLayer);

    this.map.getLeafletMap().on("click", e => {
      const currentZoom = this.map.getLeafletMap().getZoom();

      // Precision changes with zoom to prevent selecting too many activities when in close proximity
      const options = {
        params: {
          lat: e.latlng.lat,
          lng: e.latlng.lng,
          precision:
            currentZoom <= 3
              ? 2.5
              : currentZoom <= 5
                ? 0.5
                : currentZoom <= 6
                  ? 0.1
                  : currentZoom <= 10
                    ? 0.03
                    : currentZoom >= 14
                      ? 0.001
                      : 0.002
        }
      };

      TrajectoryExploitationRepository.getActivitiesByPoint(options)
        .then(selectedActivitiesIds => {
          this.selectedFeatures = this.activities.filter(
            activity => selectedActivitiesIds.find(a => a === activity.id) != null
          );
          if (this.selectedFeatures.length !== 0) {
            this.showActivityDetail();
          } else {
            // Removes the current content
            this.close();
          }
        });
    });

    Promise.all([
      this.beforeMountPromise,
      this.getCategoriesPromise,
      this.tablePromise
    ]).then(() => {
      if (this.form.category != null) {
        this.$refs.statisticsTable.selectColumn(this.form.category.label);
      }
      this.redirect();
      // Getting all the employees and calling to update employees layer to represent the selected ones
      this.fetchEmployees().then(data => {
        this.employees = this.employees.concat(data);
        if (this.$route.query.employees != null) {
          this.form.employees = this.employees.filter(e =>
            this.$route.query.employees.split(",").includes(e.fullName)
          );
        }
        this.updateActivitiesLayer();
      });
    });
  },
  methods: {
    fetchEmployees() {
      const start = localDateToISOString(this.form.startDate);
      const end = this.form.endDate
        ? localDateToISOString(this.form.endDate)
        : null;

      return TrajectoryExploitationRepository.getEmployeesWithActivitiesBetween(start, end);
    },
    filterMap(from) {
      const categoryToFilter = this.categories.find(cat => cat.label === from);
      this.form.category =
        categoryToFilter !== this.form.category ? categoryToFilter : null;
      this.searchInMap();
    },
    checkForWarning() {
      if (
        this.form.endDate != null ||
        (this.form.employees != null &&
          (this.form.employees.length === 0 || this.form.employees.length > 1))
      ) {
        this.showWarning = true;
      } else {
        this.showWarning = false;
      }
    },
    redirect() {
      this.checkForWarning();
      const route = {
        name: "Record",
        params: {},
        query: {
          employees:
            this.form.employees &&
            this.form.employees.length > 0 &&
            !this.form.employees.find(e => e.id === 0)
              ? this.form.employees.map(e => e.fullName).join(",")
              : undefined,
          category: this.form.category ? this.form.category.id : undefined,
          searchType: this.form.searchType ? this.form.searchType : undefined,
          activities: this.selectedFeatures
            ? this.selectedFeatures.map(feature => feature.id).join(",")
            : undefined
        }
      };
      if (this.form.startDate && this.form.startDate !== "") {
        route.params.start = this.form.startDate.join("_");
      }
      if (this.form.endDate && this.form.endDate !== "") {
        route.params.end = this.form.endDate.join("_");
      }
      if (
        this.$route.name !== route.name ||
        JSON.stringify(this.$route.query) !== JSON.stringify(route.query) ||
        JSON.stringify(this.$route.params) !== JSON.stringify(route.params)
      ) {
        this.$router.replace(route);
      }
    },
    back() {
      this.selectedFeatures = this.backFeatures;
      this.detailComponent = this.backComponent;
    },
    showClientDetail(id, canGoBack) {
      this.backFeatures = canGoBack ? this.selectedFeatures : null;
      this.backComponent = canGoBack ? this.detailComponent : null;
      TrajectoryExploitationRepository.getClient(id)
        .then(data => {
          this.selectedFeatures = data;
          this.detailComponent = "client-detail";
        });
    },
    showEmployeeDetail(id, canGoBack) {
      this.backFeatures = canGoBack ? this.selectedFeatures : null;
      this.backComponent = canGoBack ? this.detailComponent : null;
      TrajectoryExploitationRepository.getEmployee(id)
        .then(data => {
          this.selectedFeatures = data;
          this.detailComponent = "employee-detail";
        });
    },
    showEventDetail(id, canGoBack) {
      this.backFeatures = canGoBack ? this.selectedFeatures : null;
      this.backComponent = canGoBack ? this.detailComponent : null;
      TrajectoryExploitationRepository.getEvent(id)
        .then(data => {
          this.selectedFeatures = data;
          this.detailComponent = "event-detail";
        });
    },
    close() {
      this.selectedFeatures = null;
      this.detailComponent = null;
      this.redirect();
      this.highlightItem(this.activitiesLayer, null, false);
    },
    goTo(args) {
      switch (args.component) {
        case "activityDetail":
          this.selectedFeatures = [this.activities.find(a => a.id === args.id)];
          this.showActivityDetail();
          break;
        case "employee":
          this.showEmployeeDetail(args.id, true);
          break;
        case "client":
          this.showClientDetail(args.id, true);
          break;
        case "event":
          this.showEventDetail(args.id, true);
          break;
      }
    },
    setStyleHighlightedLayer(mainLayer, idFeature, highlight = true) {
      mainLayer.getLayer().then(layer => {
        // Setting highlighted color to the specified sublayer
        layer.eachLayer(subLayer => {
          if (subLayer.feature.id === idFeature) {
            let geoJsonStyle = highlightStyle(highlight, subLayer)
            if (geoJsonStyle instanceof L.DivIcon)
              subLayer.setIcon(geoJsonStyle);
            else subLayer.setStyle(geoJsonStyle);
          }
        });
      });
    },
    highlightItem(layer, ids, highlight = true) {
      // Remove last highlighted layer
      if (oldHighlightedIds) {
        oldHighlightedIds.forEach(id => {
          this.setStyleHighlightedLayer(
            layer,
            id,
            false
          );
        });
        oldHighlightedIds = null;
      }
      if (highlight) {
        ids.forEach(id => {
          this.setStyleHighlightedLayer(
            layer,
            id
          );
        })
        oldHighlightedIds = JSON.parse(JSON.stringify(ids));
      }
    },
    saveDate(prop, data) {
      this.form[prop] = data.date;
      if (this.form.startDate) {
        if (
          !this.form.endDate ||
          compareLocalDates(this.form.startDate, this.form.endDate) < 0
        ) {
          // Eliminates date picker errors
          this.$refs.startDate.setDatePickerErrorMessage(null);
          if (this.form.endDate) {
            this.$refs.endDate.setDatePickerErrorMessage(null);
          }
          this.redirect();
          this.fetchEmployees().then(data => {
            this.employees = [] // clearing current employees' list
            this.employees = this.employees.concat(data);
            if (this.$route.query.employees != null) {
              this.form.employees = this.employees.filter(e =>
                this.$route.query.employees.split(",").includes(e.fullName)
              );
            }
            this.updateActivitiesLayer();
          });
        } else {
          this.$notify({
            text: this.$t("trajectory_exploitation.endDateError"),
            type: "error"
          });
          this.$refs[prop].setDatePickerErrorMessage(
            this.$t("calendar.endTimeValidationError")
          );
        }
      }
    },
    searchInMap() {
      // Remove the detail component
      this.detailComponent = null;
      this.backFeatures = null;
      if (this.form.searchType === 1) {
        this.form.endDate = null;
      }
      this.redirect();
      this.updateActivitiesLayer();
    },
    showActivityDetail() {
      this.detailComponent = "activity-detail";
      this.redirect();
      let selectedIds = this.selectedFeatures.map(
        feature => feature.id
      );
      this.highlightItem(
        this.activitiesLayer,
        selectedIds
      );
    },
    _getGeoJSONFeature(item) {
      let geoJSONFeature = {
        geometry: item.location ? item.location : item.geom,
        type: "Feature",
        id: item.id,
        properties: {}
      };
      if (item.fullName) {
        geoJSONFeature.properties["displayString"] = item.fullName;
      }
      if (item.category) {
        geoJSONFeature.properties["category_color"] = item.category.color;
      }
      return geoJSONFeature;
    },
    updateActivitiesLayer() {
      // If there is no start and end dates selected, delete all the activities from the map
      if (
        this.form.startDate &&
        (this.form.endDate || this.form.searchType === 1)
      ) {
        const employeesQuery = this.form.employees.filter(e => e.id !== 0);
        const options = {
          params: {
            employee:
              employeesQuery.length > 0
                ? employeesQuery.map(e => e.id).join(",")
                : undefined,
            start: localDateToISOString(this.form.startDate),
            end:
              this.form.endDate != null
                ? localDateToISOString(this.form.endDate)
                : localDateToISOString(this.form.startDate),
            categories: this.form.category ? this.form.category.id : undefined
          }
        };
        TrajectoryExploitationRepository.getAllActivities(options)
          .then(data => {
            this.activities = data;

            updateLayer(this.activitiesLayer, this.activities, this._getGeoJSONFeature).then(() => {
              // Focus on activities markers
              this.activitiesLayer.getBounds().then(activitiesBounds => {
                if (activitiesBounds.isValid()) {
                  this.map.centerView(activitiesBounds.pad(0.2));
                }
              });
              this.activitiesLayer.getLayer().then(layer => {
                // Setting color of the sublayers depending on its category
                layer.eachLayer(subLayer => {
                  subLayer.setStyle({
                    color: subLayer.feature.properties.category_color,
                    fillColor: subLayer.feature.properties.category_color,
                    opacity: 0.55,
                    fillOpacity:
                      subLayer.feature.geometry.type === "Point" ? 0.55 : 0
                  });
                });
              });
            });

            // If we received an activity id from the URL, we show the details of it
            if (this.form.activities) {
              this.selectedFeatures = this.activities.filter(
                activity =>
                  this.form.activities.find(id => id === activity.id) != null
              );
              this.showActivityDetail();
            }
          });
      } else {
        this.activitiesLayer.getLayer().then(layer => {
          layer.eachLayer(subLayer => {
            layer.removeLayer(subLayer._leaflet_id);
          });
        });
      }
      // And update the statistics table
      this.updateStatisticsData();
    },
    updateStatisticsData() {
      if (
        this.form.startDate &&
        (this.form.endDate || this.form.searchType === 1)
      ) {
        const employeesQuery = this.form.employees.filter(e => e.id !== 0);
        TrajectoryExploitationRepository.getStatistics({
          params: {
            start: localDateToISOString(this.form.startDate),
            end:
              this.form.endDate != null
                ? localDateToISOString(this.form.endDate)
                : localDateToISOString(this.form.startDate),
            employees:
              employeesQuery.length > 0
                ? employeesQuery.map(e => e.id).join(",")
                : undefined
          }
        }).then(data => {
          this.statisticsData = data;
          this.showLegend = true;
        });
      } else {
        this.statisticsData = [];
      }
    }
  }
};
</script>
<style scoped>
#map {
  height: 52vh;
  z-index: 1;
}
.card {
  height: 52vh;
  overflow: overlay;
}
.custom-title {
  margin-right: 10px;
  margin-left: 10px;
  margin-top: 6px;
}
.custom-select {
  max-width: 100px;
  margin-right: 12px;
  margin-top: 4px;
}
.legend-label {
  font-size: 15px;
  align-self: center;
  color: rgba(0, 0, 0, 0.54);
}
@media (max-width: 992px) {
  .card {
    height: auto;
  }
  #map {
    height: 55vh;
    z-index: 1;
  }
}
#click-on-activity-label {
  color: lightslategray;
  font-size: 20px;
}
</style>
/*% } %*/
