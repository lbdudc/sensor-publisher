/*% if (feature.MWM_TE_VisitsRecord) { %*/
<template>
  <v-container fluid>
    <!-- Filters -->
    <v-row no-gutters class="mt-1">
      <label class="headline custom-title ml-0">
        {{ $t("trajectory_exploitation.visits_record.title") }}
      </label>
      <v-select
        v-model="form.searchType"
        class="custom-select"
        item-text="label"
        item-value="id"
        :items="searchTypes"
        @change="updateData()"
        dense
        solo
      ></v-select>
      <v-col class="date-picker-container mt-2">
        <dateAndHourPicker
          :datePickerProp="{
            data: form.startDate,
            label:
              form.searchType == 1
                ? $t('trajectory_exploitation.date')
                : $t('trajectory_exploitation.startDate'),
            mandatory: true
          }"
          @update-time="saveDate('startDate', ...arguments)"
          ref="startDate"
        ></dateAndHourPicker>
      </v-col>
      <label class="headline custom-title" v-show="form.searchType != 1">
        {{ $t("trajectory_exploitation.and") }}
      </label>
      <v-col class="date-picker-container mt-2" v-if="form.searchType != 1">
        <dateAndHourPicker
          :datePickerProp="{
            data: form.endDate,
            label: $t('trajectory_exploitation.endDate'),
            mandatory: true
          }"
          ref="endDate"
          @update-time="saveDate('endDate', ...arguments)"
        ></dateAndHourPicker>
      </v-col>
      <label class="headline custom-title">
        {{ $t("trajectory_exploitation.by") }}
      </label>
      <v-col cols="12" md="4" class="pt-1 autocomplete-container">
        <autocomplete
          v-model="form.employees"
          :label="$t('trajectory_exploitation.visits_record.select_employees')"
          :items="employees"
          item-text="fullName"
          :error="employeesError"
          :no-data-text="$t('trajectory_exploitation.visits_record.no_data.employees')"
          clearable
          return-object
          multiple
          @change="updateData()"
          dense
          solo
          abreviate
          select-all
        ></autocomplete>
      </v-col>
      <label class="headline custom-title">
        {{ $t("trajectory_exploitation.to") }}
      </label>
      <v-col cols="12" md="4" class="pt-1 autocomplete-container">
        <autocomplete
          v-model="form.client"
          :label="$t('trajectory_exploitation.visits_record.select_client')"
          :items="clients"
          item-text="fullName"
          :error="clientsError"
          :no-data-text="$t('trajectory_exploitation.visits_record.no_data.clients')"
          clearable
          return-object
          @change="updateData()"
          dense
          solo
          abreviate
        ></autocomplete>
      </v-col>
    </v-row>
    <!-- Map & detail -->
    <v-row no-gutters>
      <v-col cols="12" md="6" ref="mapContainer">
        <v-container ref="map" id="map"></v-container>
      </v-col>
      <v-col cols="12" md="6" class="pl-md-2 pt-2 pt-md-0 pb-0">
        <v-card class="pl-md-2 card">
          <template v-if="selectedVisits">
            <!-- Client data -->
            <v-row no-gutters class="pt-2">
              <v-col cols="2"></v-col>
              <v-col cols="8" class="text-center">
                <h3>{{ $t("trajectory_exploitation.visits_record.selected_visits") }}</h3>
              </v-col>
              <v-col cols="2" align="start">
                <v-btn icon @click.native="close" class="details-close-button">
                  <v-icon class="details-close-button material-icons">
                    close
                  </v-icon>
                </v-btn>
              </v-col>
            </v-row>
            <v-row no-gutters class="pt-2 pl-3 visits-container">
              <v-col
                cols="12"
                v-for="selectedClient in selectedClients"
                :key="selectedClient.id"
                class="pr-3 pr-md-5"
              >
                <v-row>
                  <v-col cols="5" lg="2" class="details-remove-white-space">
                    <b>{{ $t("trajectory_exploitation.client") }}:</b>
                  </v-col>
                  <v-col cols="7" lg="4" class="details-remove-white-space">
                    {{ selectedClient.fullName }}
                  </v-col>
                  <v-col cols="5" lg="2" class="details-remove-white-space">
                    <b>{{ $t("trajectory_exploitation.phone") }}:</b>
                  </v-col>
                  <v-col cols="7" lg="4" class="details-remove-white-space">
                    <a class="link" :href="`tel:${selectedClient.phone}`">{{
                      selectedClient.phone
                    }}</a>
                  </v-col>
                </v-row>
                <v-col cols="12">
                  <visits-table
                    :data="visitsForClient(selectedClient)"
                  ></visits-table>
                </v-col>
                <v-divider></v-divider>
              </v-col>
            </v-row>
            <v-row class="pagination-container pt-2 pr-md-2">
              <v-col cols="2"> </v-col>
              <v-col cols="8" class="text-center">
                <v-pagination v-model="page" :length="pageCount"></v-pagination>
              </v-col>
              <v-col cols="2">
                <v-select
                  :label="
                    $t('trajectory_exploitation.visits_record.visits_per_page')
                  "
                  :items="pageSizeValues"
                  v-model="pageSize"
                >
                </v-select>
              </v-col>
            </v-row>
          </template>
          <template v-else>
            <v-container fill-height>
              <v-row class="text-center" justify="center">
                <v-col cols="12">
                  <label id="click-on-visit-label">
                    {{
                      $t("trajectory_exploitation.visits_record.detail_message")
                    }}
                  </label>
                </v-col>
              </v-row>
            </v-container>
          </template>
        </v-card>
      </v-col>
    </v-row>
    <!-- Clients & employees statistics tables -->
    <v-row no-gutters>
      <v-col cols="12" md="6" class="text-center pt-2 pb-0">
        <v-card class="table">
          <h3>
            {{ $t("trajectory_exploitation.visits_record.client_statistics") }}
          </h3>
          <clients-statistics
            :statistics-data="clientsStatisticsData"
            :sortable="false"
            :hideFooter="false"
            ref="clientsStatistics"
            class="pt-0"
          ></clients-statistics>
        </v-card>
      </v-col>
      <v-col cols="12" md="6" class="text-center pl-md-2 pt-2 pb-0">
        <v-card class="table">
          <h3>
            {{
              $t("trajectory_exploitation.visits_record.employee_statistics")
            }}
          </h3>
          <employees-statistics
            :statistics-data="employeesStatisticsData"
            :sortable="false"
            :hideFooter="false"
            ref="employeesStatistics"
            class="pt-0"
          ></employees-statistics>
        </v-card>
      </v-col>
    </v-row>
  </v-container>
</template>

<script>
import initMap from "@/common/initMap";
import DateAndHourPicker from "@/components/calendar/DateAndHourPicker";
import VisitsTable from "./VisitsTable";
import { localDateToISOString, toMilliSeconds } from "@/common/conversion-utils";
import { compareLocalDates } from "@/common/comparation-utils";
import Autocomplete from "@/components/debouncing-inputs/Autocomplete.vue";
import ClientsStatistics from "./ClientsStatisticsTable";
import EmployeesStatistics from "./EmployeesStatisticsTable";
import RepositoryFactory from "@/repositories/RepositoryFactory";

const TrajectoryExploitationRepository = RepositoryFactory.get(
  "TrajectoryExploitationRepository"
);

const HIGHLIGHT_COLOR = "#FFFF00";
const CLUSTER_COLOR = "#9ACD32";
const SINGLE_VISIT_COLOR = "#09F1EE";
const highlightStyle = (highlight, subLayer) => {
  return {
    color: highlight
      ? HIGHLIGHT_COLOR
      : subLayer.feature.properties.count > 1
        ? CLUSTER_COLOR
        : SINGLE_VISIT_COLOR,
    fillColor: highlight
      ? HIGHLIGHT_COLOR
      : subLayer.feature.properties.count > 1
        ? CLUSTER_COLOR
        : SINGLE_VISIT_COLOR,
    fillOpacity:
      subLayer.feature.geometry.type == "Point"
        ? highlight
          ? 1.0
          : 0.55
        : 0,
    opacity: highlight ? 1.0 : 0.55
  };
};
var oldHighlightedIds = null;
var map = null;
var visitsLayer = null;
var visits = [];

export default {
  data() {
    return {
      form: {
        employees: [],
        startDate: null,
        endDate: null,
        searchType: 1,
        client: undefined
      },
      searchTypes: [
        { id: 1, label: this.$t("trajectory_exploitation.in") },
        { id: 2, label: this.$t("trajectory_exploitation.between") }
      ],
      clients: [],
      clientsError: false,
      clientsStatisticsData: [],
      employees: [],
      employeesError: false,
      employeesStatisticsData: [],
      page: 1,
      pageCount: 1,
      pageSize: 10,
      pageSizeValues: [5, 10, 20, 30],
      selectedClients: [],
      selectedVisits: null,
      tableVisits: [],
      visitsEmployees: [],
      visitsIds: [],
    };
  },
  components: {
    DateAndHourPicker,
    Autocomplete,
    EmployeesStatistics,
    ClientsStatistics,
    VisitsTable
  },
  watch: {
    page: function () {
      this.fetchVisitsPage();
    },
    pageSize: function () {
      this.fetchVisitsPage();
    },
    pageCount: function(val) {
      if (val < this.page) this.page = 1;
    }
  },
  computed: {
    showClientsOnVisits() {
      return this.selectedClients.length > 1;
    }
  },
  beforeMount() {
    // setting dates
    this.form.searchType = this.$route.query.searchType
      ? parseInt(this.$route.query.searchType)
      : 1;

    if (this.$route.params.start) {
      this.form.startDate = this.$route.params.start
        .split("_")
        .map(str => parseInt(str));
      if (this.form.searchType == 2 && this.$route.params.end) {
        this.form.endDate = this.$route.params.end
          .split("_")
          .map(str => parseInt(str));
      }
    } else {
      const today = new Date();
      const todayArray = [
        today.getFullYear(),
        today.getMonth() + 1,
        today.getDate()
      ];
      this.form.startDate = todayArray;
      if (this.form.searchType == 2) {
        this.form.endDate = todayArray;
      }
    }
  },
  async mounted() {
    // init map
    map = initMap("map", "visitsRecord", [
      [41.508742458803326, -4.087890625],
      [44.508742458803326, -12.087890625]
    ]);

    // adding visits layer
    visitsLayer = new MV.GeoJSONLayer(
      {
        type: "FeatureCollection",
        features: []
      },
      {
        id: "visits-geom",
        label: "visits-geom",
        baseLayer: false,
        click: event => this.showVisits(event.layer.feature)
      }
    );

    map.addLayer(visitsLayer);

    map.getLeafletMap().on("zoomend", () => this.updateVisitsLayer(true));

    // NOTE: send data requests after clients & employees data is fetched
    // for be able to send clients & employees as params of the data requests
    await this.fetchPersonnelData();
    this.updateData();
  },
  methods: {
    fetchPersonnelData() {
      const start = localDateToISOString(this.form.startDate);
      const end = this.form.endDate
        ? localDateToISOString(this.form.endDate)
        : null;

      // clearing arrays
      this.employees.splice(0);
      this.clients.splice(0);

      // fetch employees promise
      let employeesFetchPm = TrajectoryExploitationRepository.getEmployeesWithVisitsBetween(start, end, "DONE");
      // fetch clients promise
      let clientsFetchPm = TrajectoryExploitationRepository.getClientsWithVisitsBetween(start, end, "DONE");

      return Promise.all([employeesFetchPm, clientsFetchPm])
      .then(data => {
        this.employees = this.employees.concat(data[0]);
        if (this.$route.query.employees != null) {
          this.form.employees = this.employees.filter(e =>
            this.$route.query.employees.split(",").includes(e.fullName)
          );
        }
        this.clients = this.clients.concat(data[1]);
        if (this.$route.query.client != null) {
          this.form.client = this.clients.find(
            c => this.$route.query.client === c.fullName
          );
        }
      });
    },
    fetchVisitsPage() {
      TrajectoryExploitationRepository.getAllEventsById(this.visitsIds, this.page, this.pageSize)
        .then(data => {
          this.selectedVisits = data.content;
          this.pageCount = data.totalPages;
          // assigning clients and employees
          let clients = this.selectedVisits.map(v => v.client);
          let employees = this.selectedVisits.map(v => v.employee);

          // removing duplicated items from arrays
          this.selectedClients = clients.filter(
            (item, pos) => clients.findIndex(c => c.id === item.id) === pos
          );
          this.visitsEmployees = employees.filter(
            (item, pos) => employees.findIndex(e => e.id === item.id) === pos
          );
        });
    },
    async saveDate(prop, data) {
      this.form[prop] = data.date;
      if (this.form.startDate) {
        if (
          !this.form.endDate ||
          compareLocalDates(this.form.startDate, this.form.endDate) < 0
        ) {
          // Eliminates date picker errors
          this.$refs.startDate.setDatePickerErrorMessage(null);
          if (this.form.endDate) {
            this.$refs.endDate.setDatePickerErrorMessage(null);
          }
          // NOTE: send data requests after clients & employees data is fetched
          // for be able to send clients & employees as params of the data requests
          await this.fetchPersonnelData();
          this.updateData();
        } else {
          this.$notify({
            text: this.$t("trajectory_exploitation.endDateError"),
            type: "error"
          });
          this.$refs[prop].setDatePickerErrorMessage(
            this.$t("calendar.endTimeValidationError")
          );
        }
      }
    },
    redirect() {
      const route = {
        name: "VisitsRecord",
        params: {},
        query: {
          employees:
            this.form.employees &&
              this.form.employees.length > 0 &&
              !this.form.employees.find(e => e.id === 0)
              ? this.form.employees.map(e => e.fullName).join(",")
              : undefined,
          client: this.form.client ? this.form.client.fullName : undefined,
          searchType: this.form.searchType ? this.form.searchType : undefined
        }
      };
      if (this.form.startDate && this.form.startDate !== "") {
        route.params.start = this.form.startDate.join("_");
      }
      if (this.form.endDate && this.form.endDate !== "") {
        route.params.end = this.form.endDate.join("_");
      }
      // NOTE: we check route params separately instead of use JSON.stringify
      // because backPrevious/Action flags can be included as params,
      // so the new route will never have them so it would always redirect
      // to new route and cause a redundant navigation error
      if (
        this.$route.name !== route.name ||
        JSON.stringify(this.$route.query) !== JSON.stringify(route.query) ||
        this.$route.params.start !== route.params.start ||
        this.$route.params.end !== route.params.end
      ) {
        this.$router.replace(route);
      }
    },
    updateData() {
      if (this.form.searchType === 1) {
        this.form.endDate = null;
      }
      this.redirect();
      this.updateVisitsLayer();
      this.updateStatisticsData();
    },
    _getGeoJSONFeature(item) {
      return {
        geometry: item.geom,
        type: "Feature",
        id: item.visits[0], // setting first visit id by default
        properties: {
          count: item.count,
          visits: item.visits
        }
      };
    },
    centerMap() {
      // Focus on visits markers
      visitsLayer.getLayer().then(layer => {
        if (layer.getBounds().isValid())
          map.centerView({
            center: layer.getBounds().pad(0.2).getCenter(),
            zoom: map.getLeafletMap().getZoom()
          });
      });
    },
    updateLayer(receivedLayer, list) {
      return receivedLayer.getLayer().then(layer => {
        layer.eachLayer(subLayer => {
          layer.removeLayer(subLayer);
        });
        list.forEach(item => {
          layer.addData(this._getGeoJSONFeature(item));
        });
      });
    },
    setStyleHighlightedLayer(mainLayer, idFeature, highlight = true) {
      mainLayer.getLayer().then(layer => {
        // Setting highlighted color to the specified sublayer
        layer.eachLayer(subLayer => {
          if (subLayer.feature.id === idFeature) {
            let geoJsonStyle = highlightStyle(highlight, subLayer)
            if (geoJsonStyle instanceof L.DivIcon)
              subLayer.setIcon(geoJsonStyle);
            else subLayer.setStyle(geoJsonStyle);
          }
        });
      });
    },
    highlightItem(layer, ids, highlight = true) {
      // Remove last highlighted layer
      if (oldHighlightedIds) {
        oldHighlightedIds.forEach(id => {
          this.setStyleHighlightedLayer(
            layer,
            id,
            false
          );
        });
        oldHighlightedIds = null;
      }
      if (highlight) {
        ids.forEach(id => {
          this.setStyleHighlightedLayer(
            layer,
            id
          );
        })
        oldHighlightedIds = JSON.parse(JSON.stringify(ids));
      }
    },
    updateVisitsLayer(zoomed = false) {
      // If there is no start and end dates selected, delete all visits from the map
      if (
        this.form.startDate &&
        (this.form.endDate || this.form.searchType === 1)
      ) {
        const currentZoom = map.getLeafletMap().getZoom();
        const employeesQuery = this.form.employees.filter(e => e.id !== 0);
        return TrajectoryExploitationRepository.getEventsClustered({
          params: {
            start: toMilliSeconds(this.form.startDate.join("-")),
            end:
              this.form.endDate != null
                ? toMilliSeconds(this.form.endDate.join("-"))
                : toMilliSeconds(this.form.startDate.join("-")),
            state: "DONE",
            distance:
              currentZoom <= 3
                ? 2.5
                : currentZoom <= 5
                ? 0.5
                : currentZoom <= 6
                ? 0.25
                : currentZoom <= 7
                ? 0.15
                : currentZoom <= 10
                ? 0.075
                : currentZoom <= 13
                ? 0.01
                : 0.001,
            employee:
              employeesQuery.length > 0
                ? employeesQuery.map(e => e.id).join(",")
                : undefined,
            client: this.form.client != null ? this.form.client.id : undefined
          }
        }).then(data => {
          visits = data;

          this.updateLayer(visitsLayer, visits).then(() => {
            if (!zoomed)
              this.centerMap();
            visitsLayer.getLayer().then(layer => {
              // Setting color of the sublayers depending on its category
              layer.eachLayer(subLayer => {
                if (subLayer.feature.properties.count > 1) {
                  subLayer
                    .bindTooltip(String(subLayer.feature.properties.count), {
                      permanent: true,
                      direction: "center",
                      className: "cluster-counter"
                    })
                    .openTooltip();
                  subLayer.setStyle({
                    radius: 15,
                    color: CLUSTER_COLOR,
                    fillColor: CLUSTER_COLOR,
                    opacity: 0.55,
                    fillOpacity:
                      subLayer.feature.geometry.type === "Point" ? 0.55 : 0
                  });
                } else
                  subLayer.setStyle({
                    color: SINGLE_VISIT_COLOR,
                    fillColor: SINGLE_VISIT_COLOR,
                    opacity: 0.55,
                    fillOpacity:
                      subLayer.feature.geometry.type === "Point" ? 0.55 : 0
                  });
              });
            });
          });
        });
      } else {
        return visitsLayer.getLayer().then(layer => {
          layer.eachLayer(subLayer => {
            layer.removeLayer(subLayer);
          });
        });
      }
    },
    close() {
      this.selectedClients.splice(0);
      this.selectedVisits = null;
      this.visitsEmployees.splice(0);
      this.highlightItem(null, false);
    },
    visitsForClient(client) {
      return this.selectedVisits.filter(v => v.client.id === client.id);
    },
    showVisits(feature) {
      // Reinitializing variables
      this.selectedClients = [];
      this.visitsEmployees = [];
      this.page = 1;
      this.pageSize = 10;

      //IDs to query by
      this.visitsIds = feature.properties.visits;

      this.fetchVisitsPage();

      this.highlightItem(visitsLayer, [feature.id]);
    },
    updateStatisticsData() {
      if (
        this.form.startDate &&
        (this.form.endDate || this.form.searchType === 1)
      ) {
        const employeesQuery = this.form.employees.filter(e => e.id !== 0);
        let options = {
          params: {
            start: this.form.startDate
              ? localDateToISOString(this.form.startDate)
              : undefined,
            end:
              this.form.endDate != null
                ? localDateToISOString(this.form.endDate)
                : undefined,
            clients: this.form.client ? this.form.client.id : undefined,
            employees:
              employeesQuery.length > 0
                ? employeesQuery.map(e => e.id).join(",")
                : undefined,
            type: this.form.searchType === 1 ? "In" : "Between"
          }
        };
        TrajectoryExploitationRepository.getClientsVisitStatistics(options)
          .then(data => this.clientsStatisticsData = data);

        options = {
          params: {
            start: this.form.startDate
              ? localDateToISOString(this.form.startDate)
              : undefined,
            end:
              this.form.endDate != null
                ? localDateToISOString(this.form.endDate)
                : undefined,
            clients: this.form.client ? this.form.client.id : undefined,
            employees:
              employeesQuery.length > 0
                ? employeesQuery.map(e => e.id).join(",")
                : undefined,
            type: this.form.searchType === 1 ? "In" : "Between"
          }
        };
        TrajectoryExploitationRepository.getEmployeesVisitStatistics(options)
          .then(data => this.employeesStatisticsData = data);

      } else {
        this.clientsStatisticsData.splice(0);
        this.employeesStatisticsData.splice(0);
      }
    }
  }
};
</script>
<style scoped>
.autocomplete-container {
  max-width: 300px;
}
.custom-select {
  max-width: 100px;
  margin-right: 12px;
  margin-top: 4px;
}
.custom-title {
  margin-right: 10px;
  margin-left: 10px;
  margin-top: 6px;
}
#map {
  height: 52vh;
  z-index: 1;
}
.card {
  height: 52vh;
  overflow: hidden;
}
.visits-container {
  height: 70%;
  overflow-y: auto;
}
.pagination-container {
  height: 20%;
  overflow: hidden;
}
.table {
  height: 30vh;
}
#click-on-visit-label {
  color: lightslategray;
  font-size: 20px;
}
@media (max-width: 992px) {
  .card {
    height: auto;
    overflow: hidden;
  }
  .table {
    height: auto;
  }
  #map {
    height: 55vh;
    z-index: 1;
  }
}
</style>
/*% } %*/
