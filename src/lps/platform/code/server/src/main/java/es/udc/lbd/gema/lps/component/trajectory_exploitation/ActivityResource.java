/*% if (feature.MWM_TE_ActivitiesRecord || feature.MWM_TE_Statistics) { %*/
package es.udc.lbd.gema.lps.component.trajectory_exploitation;

import es.udc.lbd.gema.lps.component.gema.model.domain.enums.AdvancedQueryTemporalRelation;
import es.udc.lbd.gema.lps.component.gema.model.domain.enums.AdvancedQueryTimeComparation;
import es.udc.lbd.gema.lps.component.gema.model.domain.enums.DelimitedZoneSearchType;
import es.udc.lbd.gema.lps.component.gema.model.service.ActivityService;
import es.udc.lbd.gema.lps.component.gema.model.service.dto.ActivityDTO;
import es.udc.lbd.gema.lps.component.gema.model.service.dto.ActivityRequestDTO;
import es.udc.lbd.gema.lps.component.gema.model.service.dto.ActivityStatisticsDTO;
import java.time.LocalDate;
import java.util.List;
import javax.inject.Inject;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(ActivityResource.ACTIVITY_RESOURCE_URL)
public class ActivityResource {

  public static final String ACTIVITY_RESOURCE_URL = "/api/trajectory_exploitation/activities";

  private static final Logger log = LoggerFactory.getLogger(ActivityResource.class);

  @Inject private ActivityService activityService;

  @GetMapping
  public ResponseEntity<List<ActivityDTO>> findAll(
    @RequestParam(name = "categories", required = false) List<Long> categories,
    @RequestParam(name = "start", required = false)
    @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
      LocalDate start,
    @RequestParam(name = "end", required = false)
    @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
      LocalDate end,
    @RequestParam(name = "employee", required = false) List<Long> employee,
    @RequestParam(name = "event", required = false) List<Long> event,
    @RequestParam(name = "client", required = false) List<Long> client,
    @RequestParam(name = "bbox", required = false) String wkt,
    @RequestParam(name = "delimitedZoneSearchType", required = false)
      DelimitedZoneSearchType delimitedZoneSearchType,
    @RequestParam(name = "advancedQueryTemporalRelation", required = false)
      AdvancedQueryTemporalRelation advancedQueryTemporalRelation,
    @RequestParam(name = "advancedQueryCategoryId", required = false)
      Long advancedQueryCategoryId,
    @RequestParam(name = "advancedQueryTimeComparation", required = false)
      AdvancedQueryTimeComparation advancedQueryTimeComparation,
    @RequestParam(name = "advancedQueryTime", required = false) Long advancedQueryTime) {

    List<ActivityDTO> activitiesDTO;
    Geometry bbox = null;

    if (wkt != null) {
      WKTReader reader = new WKTReader();
      try {
        bbox = reader.read(wkt);
      } catch (ParseException e) {
        return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
      }
    }

    activitiesDTO =
      activityService.findAll(
        categories,
        start,
        end,
        employee,
        client,
        event,
        bbox,
        delimitedZoneSearchType,
        advancedQueryTemporalRelation,
        advancedQueryCategoryId,
        advancedQueryTimeComparation,
        advancedQueryTime);

    return new ResponseEntity<>(activitiesDTO, HttpStatus.OK);
  }

  @PostMapping
  public ResponseEntity<List<ActivityDTO>> findAllByPost(
    @RequestBody ActivityRequestDTO activityRequestDTO) {
    List<ActivityDTO> activitiesDTO = null;
    activityService.findAll(
      activityRequestDTO.getCategories(),
      activityRequestDTO.getStart(),
      activityRequestDTO.getEnd(),
      activityRequestDTO.getEmployee(),
      activityRequestDTO.getClient(),
      activityRequestDTO.getEvent(),
      activityRequestDTO.getBbox(),
      activityRequestDTO.getDelimitedZoneSearchType(),
      activityRequestDTO.getAdvancedQueryTemporalRelation(),
      activityRequestDTO.getCategoryToSearch(),
      activityRequestDTO.getAdvancedQueryTimeComparation(),
      activityRequestDTO.getAdvancedQueryTime());

    return new ResponseEntity<>(activitiesDTO, HttpStatus.OK);
  }

  @GetMapping("/first-day")
  public ResponseEntity<LocalDate> getFirstDayWithActivities() {
    LocalDate firstDay = activityService.getFirstDayWithActivities();
    return new ResponseEntity<>(firstDay, HttpStatus.OK);
  }

  @GetMapping("/last-day")
  public ResponseEntity<LocalDate> getLastDayWithActivities() {
    LocalDate lastDay = activityService.getLastDayWithActivities();
    return new ResponseEntity<>(lastDay, HttpStatus.OK);
  }

  @GetMapping("/statistics")
  public ResponseEntity<List<ActivityStatisticsDTO>> getActivitiesStatistics(
    @RequestParam(name = "start", required = false)
    @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
      LocalDate start,
    @RequestParam(name = "end", required = false)
    @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
      LocalDate end,
    @RequestParam(name = "employees", required = false) List<Long> employees,
    @RequestParam(name = "type", required = false) String type) {
    List<ActivityStatisticsDTO> activitiesStatisticsDTOs =
      activityService.getActivitiesStatistics(start, end, employees, type);
    return new ResponseEntity<>(activitiesStatisticsDTOs, HttpStatus.OK);
  }

  @GetMapping("/find-by-point")
  public ResponseEntity<List<Long>> getActivitiesByPoint(
    @RequestParam(name = "lat", required = true) Float pointLat,
    @RequestParam(name = "lng", required = true) Float pointLng,
    @RequestParam(name = "precision", required = true) Float precision) {
    List<Long> result = activityService.getActivitiesByPoint(pointLat, pointLng, precision);
    return new ResponseEntity<>(result, HttpStatus.OK);
  }
}
/*% } %*/
