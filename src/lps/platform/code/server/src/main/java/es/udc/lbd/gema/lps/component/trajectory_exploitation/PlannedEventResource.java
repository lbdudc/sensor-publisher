/*% if (feature.MWM_TE_Realtime || feature.MWM_TE_Planning || feature.MWM_TE_ActivitiesRecord || feature.MWM_TE_VisitsRecord) { %*/
package es.udc.lbd.gema.lps.component.trajectory_exploitation;

import es.udc.lbd.gema.lps.component.gema.model.domain.PlannedEvent;
import es.udc.lbd.gema.lps.component.gema.model.domain.PlannedEventState;
import es.udc.lbd.gema.lps.component.gema.model.service.PlannedEventService;
import es.udc.lbd.gema.lps.component.gema.model.service.dto.PlannedEventDTO;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.List;
import javax.inject.Inject;
import net.kaczmarzyk.spring.data.jpa.domain.*;
import net.kaczmarzyk.spring.data.jpa.web.annotation.And;
import net.kaczmarzyk.spring.data.jpa.web.annotation.Spec;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
/*% if (feature.MWM_TE_VisitsRecord) { %*/
import es.udc.lbd.gema.lps.component.gema.model.service.dto.ClusteredPlannedEventsDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import net.kaczmarzyk.spring.data.jpa.domain.In;
/*% } %*/
/*% if (feature.MWM_EmployeeAuthentication) { %*/
import es.udc.lbd.gema.lps.component.gema.model.service.exception.ForbiddenUserException;
/*% } %*/

@RestController
@RequestMapping(PlannedEventResource.PLANNED_EVENT_RESOURCE_URL)
public class PlannedEventResource {

  public static final String PLANNED_EVENT_RESOURCE_URL = "/api/trajectory_exploitation/events";

  private static final Logger log = LoggerFactory.getLogger(PlannedEventResource.class);

  @Inject private PlannedEventService plannedEventService;

  /*% if (feature.MWM_TE_Realtime || feature.MWM_TE_Planning) { %*/
  @GetMapping
  public ResponseEntity<List<PlannedEventDTO>> findAll(
    @And({
      @Spec(path="date", params= "start", spec=GreaterThanOrEqual.class),
      @Spec(path="date", params= "end", spec=LessThanOrEqual.class),
      @Spec(path = "employee.id", paramSeparator = ',', params = "employee", spec = In.class),
      @Spec(path = "client.id", paramSeparator = ',', params = "client", spec = In.class),
      @Spec(path = "description", spec = Like.class),
      @Spec(path = "state", spec = Equal.class)
    })
      Specification<PlannedEvent> specification,
    @RequestParam(name = "label", required = false) List<String> label,
    @RequestParam(name = "bbox", required = false) String wkt) {

    List<PlannedEventDTO> eventsDTO;
    Geometry bbox = null;

    if (wkt != null) {
      WKTReader reader = new WKTReader();
      try {
        bbox = reader.read(wkt);
      } catch (ParseException e) {
        return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
      }
    }

    eventsDTO = plannedEventService.findAll(specification, label, bbox);

    return new ResponseEntity<>(eventsDTO, HttpStatus.OK);
  }
  /*% } %*/
  /*% if (feature.MWM_TE_VisitsRecord) { %*/
  @GetMapping("/id-search")
  public ResponseEntity<Page<PlannedEventDTO>> findAllById(
      @PageableDefault(page = 0, size = 100000, sort = "id") Pageable pageable,
      @Spec(path = "id", params = "list", paramSeparator = ',', spec = In.class) Specification idsSpec) {

    Page<PlannedEventDTO> pageDto = plannedEventService.findAllById(pageable, idsSpec);

    return new ResponseEntity<Page<PlannedEventDTO>>(pageDto, HttpStatus.OK);
  }

  @GetMapping("/clusters")
  public ResponseEntity<List<ClusteredPlannedEventsDTO>> findClusteredVisits(
      @RequestParam(name = "start", required = false) Long start,
      @RequestParam(name = "end", required = false) Long end,
      @RequestParam(name = "state", required = false) PlannedEventState state,
      @RequestParam(name = "employee", required = false) List<Long> employee,
      @RequestParam(name = "client", required = false) List<Long> client,
      @RequestParam(name = "distance", required = true) Double distance) {

    List<ClusteredPlannedEventsDTO> clusters;

    LocalDate startDate = null;
    LocalDate endDate = null;
    if (start != null) {
      startDate = Instant.ofEpochMilli(start).atZone(ZoneId.systemDefault()).toLocalDate();
      endDate = Instant.ofEpochMilli(end).atZone(ZoneId.systemDefault()).toLocalDate();
    }

    clusters =
        plannedEventService.findClusteredVisits(
            startDate, endDate, state, employee, client, distance);

    return new ResponseEntity<List<ClusteredPlannedEventsDTO>>(clusters, HttpStatus.OK);
  }
  /*% } %*/
  /*% if (feature.MWM_TE_Realtime || feature.MWM_TE_Planning || feature.MWM_TE_ActivitiesRecord) { %*/
  @GetMapping("/{id}")
  public ResponseEntity<PlannedEventDTO> findById(@PathVariable Long id) {
    /*% if (feature.MWM_EmployeeAuthentication) { %*/
    PlannedEventDTO plannedEventDTO;
    try {
      plannedEventDTO = plannedEventService.findById(id);
    } catch (ForbiddenUserException e) {
		  return new ResponseEntity<>(HttpStatus.FORBIDDEN);
    }
    /*% } else { %*/
    PlannedEventDTO plannedEventDTO = plannedEventService.findById(id);
    /*% } %*/
    if (plannedEventDTO != null) {
      return new ResponseEntity<>(plannedEventDTO, HttpStatus.OK);
    } else {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
  }
  /*% } %*/
}
/*% } %*/
